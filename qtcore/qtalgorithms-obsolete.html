<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qalgorithms.qdoc -->
  <title>Obsolete Members for &lt;QtAlgorithms&gt; | Qt Core 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtcore-index.html">Qt Core</a></td><td >Obsolete Members for &lt;QtAlgorithms&gt;</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar"><div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Obsolete Members for &lt;QtAlgorithms&gt;</h1>
<p><b>The following members of class <a href="qtalgorithms.html">&lt;QtAlgorithms&gt;</a> are obsolete.</b> They are provided to keep old source code working. We strongly advise against using them in new code.</p>
<h2>Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind-1">qBinaryFind</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qBinaryFind-2">qBinaryFind</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>OutputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a></b>(InputIterator <i>begin1</i>, InputIterator <i>end1</i>, OutputIterator <i>begin2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>BiIterator2 </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCopyBackward">qCopyBackward</a></b>(BiIterator1 <i>begin1</i>, BiIterator1 <i>end1</i>, BiIterator2 <i>end2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCount">qCount</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp;<i>value</i>, Size &amp;<i>n</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qCount-1">qCount</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>, Size &amp;<i>n</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>bool </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qEqual">qEqual</a></b>(InputIterator1 <i>begin1</i>, InputIterator1 <i>end1</i>, InputIterator2 <i>begin2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFill">qFill</a></b>(ForwardIterator <i>begin</i>, ForwardIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFill-1">qFill</a></b>(Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>InputIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFind">qFind</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qFind-1">qFind</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qGreater">qGreater</a></b>()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>LessThan </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLess">qLess</a></b>()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound-1">qLowerBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qLowerBound-2">qLowerBound</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort">qSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort-1">qSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSort-2">qSort</a></b>(Container &amp;<i>container</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort-1">qStableSort</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qStableSort-2">qStableSort</a></b>(Container &amp;<i>container</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>void </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qSwap-1">qSwap</a></b>(T &amp;<i>var1</i>, T &amp;<i>var2</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>RandomAccessIterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound-1">qUpperBound</a></b>(RandomAccessIterator <i>begin</i>, RandomAccessIterator <i>end</i>, const T &amp;<i>value</i>, LessThan <i>lessThan</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> <code>(obsolete) </code>Container::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qtalgorithms-obsolete.html#qUpperBound-2">qUpperBound</a></b>(const Container &amp;<i>container</i>, const T &amp;<i>value</i>)</td></tr>
</table></div>
<h2>Function Documentation</h2>
<!-- $$$qBinaryFind[overload1]$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qBinaryFind"><a name="qBinaryFind"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of an occurrence of <i>value</i>. If there are no occurrences of <i>value</i>, returns <i>end</i>.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>If there are many occurrences of the same value, any one of them could be returned. Use <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() if you need finer control.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span>
          qBinaryFind(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="comment">// i == vect.begin() + 2 (or 3 or 4)</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator&lt;()</code>.</p>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(), <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(), and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qBinaryFind-1"><a name="qBinaryFind-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qBinaryFind</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qBinaryFind -->
<!-- $$$qBinaryFind$$$qBinaryFindconstContainer&constT& -->
<h3 class="fn" id="qBinaryFind-2"><a name="qBinaryFind-2"></a><span class="type">Container::const_iterator</span> <span class="name">qBinaryFind</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::binary_search</code> or <code>std::lower_bound</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qBinaryFind -->
<!-- $$$qCopy[overload1]$$$qCopyInputIteratorInputIteratorOutputIterator -->
<h3 class="fn" id="qCopy"><a name="qCopy"></a><span class="type">OutputIterator</span> <span class="name">qCopy</span>(<span class="type">InputIterator</span> <i>begin1</i>, <span class="type">InputIterator</span> <i>end1</i>, <span class="type">OutputIterator</span> <i>begin2</i>)</h3>
<p>Use <code>std::copy</code> instead.</p>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [<i>begin2</i>, ..&#x2e;), in the order in which they appear.</p>
<p>The item at position <i>begin1</i> is assigned to that at position <i>begin2</i>; the item at position <i>begin1</i> + 1 is assigned to that at position <i>begin2</i> + 1; and so on.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect1(<span class="number">3</span>);
  qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect1<span class="operator">.</span>begin());
  <span class="comment">// vect: [ &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span>

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect2(<span class="number">8</span>);
  qCopy(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect2<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">2</span>);
  <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qCopyBackward">qCopyBackward</a>(), <a href="qtalgorithms.html#input-iterators">input iterators</a>, and <a href="qtalgorithms.html#output-iterators">output iterators</a>.</p>
<!-- @@@qCopy -->
<!-- $$$qCopyBackward[overload1]$$$qCopyBackwardBiIterator1BiIterator1BiIterator2 -->
<h3 class="fn" id="qCopyBackward"><a name="qCopyBackward"></a><span class="type">BiIterator2</span> <span class="name">qCopyBackward</span>(<span class="type">BiIterator1</span> <i>begin1</i>, <span class="type">BiIterator1</span> <i>end1</i>, <span class="type">BiIterator2</span> <i>end2</i>)</h3>
<p>Use <code>std::copy_backward</code> instead.</p>
<p>Copies the items from range [<i>begin1</i>, <i>end1</i>) to range [..&#x2e;, <i>end2</i>).</p>
<p>The item at position <i>end1</i> - 1 is assigned to that at position <i>end2</i> - 1; the item at position <i>end1</i> - 2 is assigned to that at position <i>end2</i> - 2; and so on.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">5</span>);
  qCopyBackward(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>end());
  <span class="comment">// vect: [ &quot;&quot;, &quot;&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot; ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a>() and <a href="qtalgorithms.html#bidirectional-iterators">bidirectional iterators</a>.</p>
<!-- @@@qCopyBackward -->
<!-- $$$qCount[overload1]$$$qCountInputIteratorInputIteratorconstT&Size& -->
<h3 class="fn" id="qCount"><a name="qCount"></a><span class="type">void</span> <span class="name">qCount</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">Size</span> &amp;<i>n</i>)</h3>
<p>Use <code>std::count</code> instead.</p>
<p>Returns the number of occurrences of <i>value</i> in the range [<i>begin</i>, <i>end</i>), which is returned in <i>n</i>. <i>n</i> is never initialized, the count is added to <i>n</i>. It is the caller's responsibility to initialize <i>n</i>.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type">int</span> countOf6 <span class="operator">=</span> <span class="number">0</span>;
  qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> countOf6);
  <span class="comment">// countOf6 == 3</span>

  <span class="type">int</span> countOf7 <span class="operator">=</span> <span class="number">0</span>;
  qCount(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> countOf7);
  <span class="comment">// countOf7 == 0</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator==()</code>.</p>
<p><b>See also </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qCount -->
<!-- $$$qCount$$$qCountconstContainer&constT&Size& -->
<h3 class="fn" id="qCount-1"><a name="qCount-1"></a><span class="type">void</span> <span class="name">qCount</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">Size</span> &amp;<i>n</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::count</code> instead.</p>
<p>Instead of operating on iterators, as in the other overload, this function operates on the specified <i>container</i> to obtain the number of instances of <i>value</i> in the variable passed as a reference in argument <i>n</i>.</p>
<!-- @@@qCount -->
<!-- $$$qEqual[overload1]$$$qEqualInputIterator1InputIterator1InputIterator2 -->
<h3 class="fn" id="qEqual"><a name="qEqual"></a><span class="type">bool</span> <span class="name">qEqual</span>(<span class="type">InputIterator1</span> <i>begin1</i>, <span class="type">InputIterator1</span> <i>end1</i>, <span class="type">InputIterator2</span> <i>begin2</i>)</h3>
<p>Use <code>std::equal</code> instead.</p>
<p>Compares the items in the range [<i>begin1</i>, <i>end1</i>) with the items in the range [<i>begin2</i>, ..&#x2e;)&#x2e; Returns <code>true</code> if all the items compare equal; otherwise returns <code>false</code>.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> vect(<span class="number">3</span>);
  vect<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;one&quot;</span>;
  vect<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;two&quot;</span>;
  vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;three&quot;</span>;

  bool ret1 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
  <span class="comment">// ret1 == true</span>

  vect<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">&quot;seven&quot;</span>;
  bool ret2 <span class="operator">=</span> qEqual(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> vect<span class="operator">.</span>begin());
  <span class="comment">// ret2 == false</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator==()</code>.</p>
<p><b>See also </b><a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qEqual -->
<!-- $$$qFill[overload1]$$$qFillForwardIteratorForwardIteratorconstT& -->
<h3 class="fn" id="qFill"><a name="qFill"></a><span class="type">void</span> <span class="name">qFill</span>(<span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Use <code>std::fill</code> instead.</p>
<p>Fills the range [<i>begin</i>, <i>end</i>) with <i>value</i>.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  qFill(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;eleven&quot;</span>);
  <span class="comment">// list: [ &quot;eleven&quot;, &quot;eleven&quot;, &quot;eleven&quot; ]</span>

  qFill(list<span class="operator">.</span>begin() <span class="operator">+</span> <span class="number">1</span><span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;six&quot;</span>);
  <span class="comment">// list: [ &quot;eleven&quot;, &quot;six&quot;, &quot;six&quot; ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qCopy">qCopy</a>() and <a href="qtalgorithms.html#forward-iterators">forward iterators</a>.</p>
<!-- @@@qFill -->
<!-- $$$qFill$$$qFillContainer&constT& -->
<h3 class="fn" id="qFill-1"><a name="qFill-1"></a><span class="type">void</span> <span class="name">qFill</span>(<span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::fill</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qFill">qFill</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qFill -->
<!-- $$$qFind[overload1]$$$qFindInputIteratorInputIteratorconstT& -->
<h3 class="fn" id="qFind"><a name="qFind"></a><span class="type">InputIterator</span> <span class="name">qFind</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Use <code>std::find</code> instead.</p>
<p>Returns an iterator to the first occurrence of <i>value</i> in a container in the range [<i>begin</i>, <i>end</i>). Returns <i>end</i> if <i>value</i> isn't found.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;one&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;two&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;three&quot;</span>;

  <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i1 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;two&quot;</span>);
  <span class="comment">// i1 == list.begin() + 1</span>

  <span class="type"><a href="qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator i2 <span class="operator">=</span> qFind(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="string">&quot;seventy&quot;</span>);
  <span class="comment">// i2 == list.end()</span>

</pre>
<p>This function requires the item type (in the example above, <a href="qstring.html">QString</a>) to implement <code>operator==()</code>.</p>
<p>If the items in the range are in ascending order, you can get faster results by using <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() or <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>() instead of qFind().</p>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>() and <a href="qtalgorithms.html#input-iterators">input iterators</a>.</p>
<!-- @@@qFind -->
<!-- $$$qFind$$$qFindconstContainer&constT& -->
<h3 class="fn" id="qFind-1"><a name="qFind-1"></a><span class="type">Container::const_iterator</span> <span class="name">qFind</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::find</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qFind">qFind</a>(<i>container</i>.constBegin(), <i>container</i>.constEnd(), <i>value</i>);</p>
<!-- @@@qFind -->
<!-- $$$qGreater[overload1]$$$qGreater -->
<h3 class="fn" id="qGreater"><a name="qGreater"></a><span class="type">LessThan</span> <span class="name">qGreater</span>()</h3>
<p>Use <code>std::greater</code> instead.</p>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() or <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>().</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qGreater<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qLess">qLess&lt;T&gt;</a>().</p>
<!-- @@@qGreater -->
<!-- $$$qLess[overload1]$$$qLess -->
<h3 class="fn" id="qLess"><a name="qLess"></a><span class="type">LessThan</span> <span class="name">qLess</span>()</h3>
<p>Use <code>std::less</code> instead.</p>
<p>Returns a functional object, or functor, that can be passed to <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() or <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>().</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> qLess<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>().</p>
<!-- @@@qLess -->
<!-- $$$qLowerBound[overload1]$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qLowerBound"><a name="qLowerBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the first occurrence of <i>value</i>. If no such item is found, returns the position where it should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

  i <span class="operator">=</span> qLowerBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>qLowerBound() can be used in conjunction with <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
          qLowerBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
          <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(begin6<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
  <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
      <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
      <span class="operator">+</span><span class="operator">+</span>i;
  }
  <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>() and <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qLowerBound-1"><a name="qLowerBound-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qLowerBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qLowerBound -->
<!-- $$$qLowerBound$$$qLowerBoundconstContainer&constT& -->
<h3 class="fn" id="qLowerBound-2"><a name="qLowerBound-2"></a><span class="type">Container::const_iterator</span> <span class="name">qLowerBound</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::lower_bound</code> instead.</p>
<p>For read-only iteration over containers, this function is broadly equivalent to <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(<i>container</i>.begin(), <i>container</i>.end(), value). However, since it returns a const iterator, you cannot use it to modify the container; for example, to insert items.</p>
<!-- @@@qLowerBound -->
<!-- $$$qSort[overload1]$$$qSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn" id="qSort"><a name="qSort"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>)</h3>
<p>Use <code>std::sort</code> instead.</p>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using the quicksort algorithm.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  qSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>() and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn" id="qSort-1"><a name="qSort-1"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::sort</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp">

  bool caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
  {
      <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
  }

  <span class="type">int</span> doSomething()
  {
      <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
      list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
      <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
      <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
  }

</pre>
<p>To sort values in reverse order, pass <a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms-obsolete.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. It is then undefined which one of the two items will appear before the other after the sort.</p>
<p>An alternative to using <a href="qtalgorithms-obsolete.html#qSort">qSort</a>() is to put the items to sort in a <a href="qmap.html">QMap</a>, using the sort key as the <a href="qmap.html">QMap</a> key. This is often more convenient than defining a <i>lessThan</i> function. For example, the following code shows how to sort a list of strings case insensitively using <a href="qmap.html">QMap</a>:</p>
<pre class="cpp">

  <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;

  <span class="type"><a href="qmap.html">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span> map;
  foreach (<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>str<span class="operator">,</span> list)
      map<span class="operator">.</span>insert(str<span class="operator">.</span>toLower()<span class="operator">,</span> str);

  list <span class="operator">=</span> map<span class="operator">.</span>values();

</pre>
<p><b>See also </b><a href="qmap.html">QMap</a>.</p>
<!-- @@@qSort -->
<!-- $$$qSort$$$qSortContainer& -->
<h3 class="fn" id="qSort-2"><a name="qSort-2"></a><span class="type">void</span> <span class="name">qSort</span>(<span class="type">Container</span> &amp;<i>container</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::sort</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qSort">qSort</a>(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qSort -->
<!-- $$$qStableSort[overload1]$$$qStableSortRandomAccessIteratorRandomAccessIterator -->
<h3 class="fn" id="qStableSort"><a name="qStableSort"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>)</h3>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>Sorts the items in range [<i>begin</i>, <i>end</i>) in ascending order using a stable sorting algorithm.</p>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  qStableSort(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
  <span class="comment">// list: [ 6, 12, 12, 33, 68 ]</span>

</pre>
<p>The sort algorithm is efficient on large data sets. It operates in <a href="containers.html#linear-logarithmic-time">linear-logarithmic time</a>, O(<i>n</i> log <i>n</i>).</p>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qSort">qSort</a>() and <a href="qtalgorithms.html#random-access-iterators">random access iterators</a>.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortRandomAccessIteratorRandomAccessIteratorLessThan -->
<h3 class="fn" id="qStableSort-1"><a name="qStableSort-1"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>For example, here's how to sort the strings in a <a href="qstringlist.html">QStringList</a> in case-insensitive alphabetical order:</p>
<pre class="cpp">

  bool caseInsensitiveLessThan(<span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s1<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>s2)
  {
      <span class="keyword">return</span> s1<span class="operator">.</span>toLower() <span class="operator">&lt;</span> s2<span class="operator">.</span>toLower();
  }

  <span class="type">int</span> doSomething()
  {
      <span class="type"><a href="qstringlist.html">QStringList</a></span> list;
      list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;AlPha&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;beTA&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;gamma&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;DELTA&quot;</span>;
      <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> caseInsensitiveLessThan);
      <span class="comment">// list: [ &quot;AlPha&quot;, &quot;beTA&quot;, &quot;DELTA&quot;, &quot;gamma&quot; ]</span>
  }

</pre>
<p>Note that earlier versions of Qt allowed using a lessThan function that took its arguments by non-const reference. From 4.3 and on this is no longer possible, the arguments has to be passed by const reference or value.</p>
<p>To sort values in reverse order, pass <a href="qtalgorithms-obsolete.html#qGreater">qGreater&lt;T&gt;</a>() as the <i>lessThan</i> parameter. For example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">33</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">68</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">12</span>;
  <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <a href="qtalgorithms-obsolete.html#qGreater">qGreater</a><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>());
  <span class="comment">// list: [ 68, 33, 12, 12, 6 ]</span>

</pre>
<p>If neither of the two items is &quot;less than&quot; the other, the items are taken to be equal. The item that appeared before the other in the original container will still appear first after the sort. This property is often useful when sorting user-visible data.</p>
<!-- @@@qStableSort -->
<!-- $$$qStableSort$$$qStableSortContainer& -->
<h3 class="fn" id="qStableSort-2"><a name="qStableSort-2"></a><span class="type">void</span> <span class="name">qStableSort</span>(<span class="type">Container</span> &amp;<i>container</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::stable_sort</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qStableSort">qStableSort</a>(<i>container</i>.begin(), <i>container</i>.end());</p>
<!-- @@@qStableSort -->
<!-- $$$qSwap$$$qSwapT&T& -->
<h3 class="fn" id="qSwap-1"><a name="qSwap-1"></a><span class="type">void</span> <span class="name">qSwap</span>(<span class="type">T</span> &amp;<i>var1</i>, <span class="type">T</span> &amp;<i>var2</i>)</h3>
<p>Use <code>std::swap</code> instead.</p>
<p>Exchanges the values of variables <i>var1</i> and <i>var2</i>.</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type">double</span> pi <span class="operator">=</span> <span class="number">3.14</span>;
  <span class="type">double</span> e <span class="operator">=</span> <span class="number">2.71</span>;

  qSwap(pi<span class="operator">,</span> e);
  <span class="comment">// pi == 2.71, e == 3.14</span>

</pre>
<!-- @@@qSwap -->
<!-- $$$qUpperBound[overload1]$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT& -->
<h3 class="fn" id="qUpperBound"><a name="qUpperBound"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>Performs a binary search of the range [<i>begin</i>, <i>end</i>) and returns the position of the one-past-the-last occurrence of <i>value</i>. If no such item is found, returns the position where the item should be inserted.</p>
<p>The items in the range [<i>begin</i>, <i>end</i>) must be sorted in ascending order; see <a href="qtalgorithms-obsolete.html#qSort">qSort</a>().</p>
<p>Example:</p>
<pre class="cpp">

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> list;
  list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;

  <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">5</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">5</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8 ]</span>

  i <span class="operator">=</span> qUpperBound(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">12</span>);
  list<span class="operator">.</span>insert(i<span class="operator">,</span> <span class="number">12</span>);
  <span class="comment">// list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]</span>

</pre>
<p>This function requires the item type (in the example above, <code>int</code>) to implement <code>operator&lt;()</code>.</p>
<p>qUpperBound() can be used in conjunction with <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() to iterate over all occurrences of the same value:</p>
<pre class="cpp">

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vect;
  vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">6</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator begin6 <span class="operator">=</span>
          <a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);
  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator end6 <span class="operator">=</span>
          qUpperBound(vect<span class="operator">.</span>begin()<span class="operator">,</span> vect<span class="operator">.</span>end()<span class="operator">,</span> <span class="number">6</span>);

  <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> begin6;
  <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> end6) {
      <span class="operator">*</span>i <span class="operator">=</span> <span class="number">7</span>;
      <span class="operator">+</span><span class="operator">+</span>i;
  }
  <span class="comment">// vect: [ 3, 3, 7, 7, 7, 8 ]</span>

</pre>
<p><b>See also </b><a href="qtalgorithms-obsolete.html#qLowerBound">qLowerBound</a>() and <a href="qtalgorithms-obsolete.html#qBinaryFind">qBinaryFind</a>().</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundRandomAccessIteratorRandomAccessIteratorconstT&LessThan -->
<h3 class="fn" id="qUpperBound-1"><a name="qUpperBound-1"></a><span class="type">RandomAccessIterator</span> <span class="name">qUpperBound</span>(<span class="type">RandomAccessIterator</span> <i>begin</i>, <span class="type">RandomAccessIterator</span> <i>end</i>, const <span class="type">T</span> &amp;<i>value</i>, <span class="type">LessThan</span> <i>lessThan</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>Uses the <i>lessThan</i> function instead of <code>operator&lt;()</code> to compare the items.</p>
<p>Note that the items in the range must be sorted according to the order specified by the <i>lessThan</i> object.</p>
<!-- @@@qUpperBound -->
<!-- $$$qUpperBound$$$qUpperBoundconstContainer&constT& -->
<h3 class="fn" id="qUpperBound-2"><a name="qUpperBound-2"></a><span class="type">Container::const_iterator</span> <span class="name">qUpperBound</span>(const <span class="type">Container</span> &amp;<i>container</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Use <code>std::upper_bound</code> instead.</p>
<p>This is the same as <a href="qtalgorithms-obsolete.html#qUpperBound">qUpperBound</a>(<i>container</i>.begin(), <i>container</i>.end(), <i>value</i>);</p>
<!-- @@@qUpperBound -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
