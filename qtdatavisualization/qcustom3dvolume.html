<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qcustom3dvolume.cpp -->
  <title>QCustom3DVolume Class | Qt Data Visualization 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtdatavisualization-index.html">Qt Data Visualization</a></td><td ><a href="qtdatavisualization-module.html">C++ Classes</a></td><td >QCustom3DVolume</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QCustom3DVolume Class</h1>
<!-- $$$QCustom3DVolume-brief -->
<p>The <a href="qcustom3dvolume.html">QCustom3DVolume</a> class is for creating volume rendered objects to be added to a graph. <a href="#details">更多...</a></p>
<!-- @@@QCustom3DVolume -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QCustom3DVolume&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  QtDataVisualization 1.2</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Instantiated By:</td><td class="memItemRight bottomAlign"> <a href="qml-qtdatavisualization-custom3dvolume.html">Custom3DVolume</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qcustom3ditem.html">QCustom3DItem</a></td></tr></table></div><ul>
<li><a href="qcustom3dvolume-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<div class="table"><table class="propsummary">
<tr><td class="topAlign"><ul>
<li class="fn"><b><a href="qcustom3dvolume.html#alphaMultiplier-prop">alphaMultiplier</a></b> : float</li>
<li class="fn"><b><a href="qcustom3dvolume.html#colorTable-prop">colorTable</a></b> : QVector&lt;QRgb&gt;</li>
<li class="fn"><b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a></b> : bool</li>
<li class="fn"><b><a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a></b> : bool</li>
<li class="fn"><b><a href="qcustom3dvolume.html#preserveOpacity-prop">preserveOpacity</a></b> : bool</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceFrameColor-prop">sliceFrameColor</a></b> : QColor</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceFrameGaps-prop">sliceFrameGaps</a></b> : QVector3D</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceFrameThicknesses-prop">sliceFrameThicknesses</a></b> : QVector3D</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceFrameWidths-prop">sliceFrameWidths</a></b> : QVector3D</li>
</ul></td><td class="topAlign"><ul>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceIndexX-prop">sliceIndexX</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceIndexY-prop">sliceIndexY</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#sliceIndexZ-prop">sliceIndexZ</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#textureData-prop">textureData</a></b> : QVector&lt;uchar&gt; *</li>
<li class="fn"><b><a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#textureHeight-prop">textureHeight</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a></b> : int</li>
<li class="fn"><b><a href="qcustom3dvolume.html#useHighDefShader-prop">useHighDefShader</a></b> : bool</li>
</ul>
</td></tr>
</table></div>
<ul>
<li class="fn">9 properties inherited from <a href="qcustom3ditem.html#properties">QCustom3DItem</a></li>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#QCustom3DVolume">QCustom3DVolume</a></b>(QObject *<i>parent</i> = Q_NULLPTR)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#QCustom3DVolume-1">QCustom3DVolume</a></b>(const QVector3D &amp;<i>position</i>, const QVector3D &amp;<i>scaling</i>, const QQuaternion &amp;<i>rotation</i>, int <i>textureWidth</i>, int <i>textureHeight</i>, int <i>textureDepth</i>, QVector&lt;uchar&gt; *<i>textureData</i>, QImage::Format <i>textureFormat</i>, const QVector&lt;QRgb&gt; &amp;<i>colorTable</i>, QObject *<i>parent</i> = Q_NULLPTR)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#dtor.QCustom3DVolume">~QCustom3DVolume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#alphaMultiplier-prop">alphaMultiplier</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QRgb&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#colorTable-prop">colorTable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;uchar&gt; *</td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#createTextureData">createTextureData</a></b>(const QVector&lt;QImage *&gt; &amp;<i>images</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#preserveOpacity-prop">preserveOpacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#renderSlice">renderSlice</a></b>(Qt::Axis <i>axis</i>, int <i>index</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#alphaMultiplier-prop">setAlphaMultiplier</a></b>(float <i>mult</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#colorTable-prop">setColorTable</a></b>(const QVector&lt;QRgb&gt; &amp;<i>colors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSliceFrames-prop">setDrawSliceFrames</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSlices-prop">setDrawSlices</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#preserveOpacity-prop">setPreserveOpacity</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameColor-prop">setSliceFrameColor</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameGaps-prop">setSliceFrameGaps</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameThicknesses-prop">setSliceFrameThicknesses</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameWidths-prop">setSliceFrameWidths</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexX-prop">setSliceIndexX</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexY-prop">setSliceIndexY</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexZ-prop">setSliceIndexZ</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#setSliceIndices">setSliceIndices</a></b>(int <i>x</i>, int <i>y</i>, int <i>z</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#setSubTextureData">setSubTextureData</a></b>(Qt::Axis <i>axis</i>, int <i>index</i>, const uchar *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#setSubTextureData-1">setSubTextureData</a></b>(Qt::Axis <i>axis</i>, int <i>index</i>, const QImage &amp;<i>image</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureData-prop">setTextureData</a></b>(QVector&lt;uchar&gt; *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureDepth-prop">setTextureDepth</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#setTextureDimensions">setTextureDimensions</a></b>(int <i>width</i>, int <i>height</i>, int <i>depth</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a></b>(QImage::Format <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureHeight-prop">setTextureHeight</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureWidth-prop">setTextureWidth</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#useHighDefShader-prop">setUseHighDefShader</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameColor-prop">sliceFrameColor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameGaps-prop">sliceFrameGaps</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameThicknesses-prop">sliceFrameThicknesses</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector3D </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameWidths-prop">sliceFrameWidths</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexX-prop">sliceIndexX</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexY-prop">sliceIndexY</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexZ-prop">sliceIndexZ</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;uchar&gt; *</td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureData-prop">textureData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureDataWidth">textureDataWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage::Format </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureFormat">textureFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureHeight-prop">textureHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#useHighDefShader-prop">useHighDefShader</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">20 public functions inherited from <a href="qcustom3ditem.html#public-functions">QCustom3DItem</a></li>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#alphaMultiplier-prop">alphaMultiplierChanged</a></b>(float <i>mult</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#colorTable-prop">colorTableChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFramesChanged</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#drawSlices-prop">drawSlicesChanged</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#preserveOpacity-prop">preserveOpacityChanged</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameColor-prop">sliceFrameColorChanged</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameGaps-prop">sliceFrameGapsChanged</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameThicknesses-prop">sliceFrameThicknessesChanged</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceFrameWidths-prop">sliceFrameWidthsChanged</a></b>(const QVector3D &amp;<i>values</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexX-prop">sliceIndexXChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexY-prop">sliceIndexYChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#sliceIndexZ-prop">sliceIndexZChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureData-prop">textureDataChanged</a></b>(QVector&lt;uchar&gt; *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureDepth-prop">textureDepthChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureFormatChanged">textureFormatChanged</a></b>(QImage::Format <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureHeight-prop">textureHeightChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#textureWidth-prop">textureWidthChanged</a></b>(int <i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcustom3dvolume.html#useHighDefShader-prop">useHighDefShaderChanged</a></b>(bool <i>enabled</i>)</td></tr>
</table></div>
<ul>
<li class="fn">9 signals inherited from <a href="qcustom3ditem.html#signals">QCustom3DItem</a></li>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<h3>附加的继承成员</h3>
<ul>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">10 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QCustom3DVolume-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qcustom3dvolume.html">QCustom3DVolume</a> class is for creating volume rendered objects to be added to a graph.</p>
<p>This class is for creating volume rendered objects to be added to a graph. A volume rendered object is a box with a 3D texture. Three slice planes are supported for the volume, one along each main axis of the volume.</p>
<p>Rendering volume objects is very performance intensive, especially when the volume is largely transparent, as the contents of the volume are ray-traced. The performance scales nearly linearly with the amount of pixels that the volume occupies on the screen, so showing the volume in a smaller view or limiting the zoom level of the graph are easy ways to improve performance. Similarly, the volume texture dimensions have a large impact on performance. If the frame rate is more important than pixel-perfect rendering of the volume contents, consider turning the high definition shader off by setting <a href="qcustom3dvolume.html#useHighDefShader-prop">useHighDefShader</a> property to <code>false</code>.</p>
<p><b>注:</b>Volumetric objects are only supported with orthographic projection.</p><p><b>注:</b>Volumetric objects utilize 3D textures, which are not supported in OpenGL ES2 environments.</p></div>
<p><b>参照 </b><a href="qabstract3dgraph.html#addCustomItem">QAbstract3DGraph::addCustomItem</a>(), <a href="qabstract3dgraph.html#orthoProjection-prop">QAbstract3DGraph::orthoProjection</a>, and <a href="qcustom3dvolume.html#useHighDefShader-prop">useHighDefShader</a>.</p>
<!-- @@@QCustom3DVolume -->
<div class="prop">
<h2>属性文件</h2>
<!-- $$$alphaMultiplier-prop$$$alphaMultiplier$$$setAlphaMultiplierfloat$$$alphaMultiplierChangedfloat -->
<h3 class="fn" id="alphaMultiplier-prop"><a name="alphaMultiplier-prop"></a><span class="name">alphaMultiplier</span> : <span class="type">float</span></h3>
<p>The alpha value of every texel of the volume texture is multiplied with this value at the render time. This can be used to introduce uniform transparency to the volume. If <a href="qcustom3dvolume.html#preserveOpacity-prop">preserveOpacity</a> is <code>true</code>, only texels with at least some transparency to begin with are affected, and fully opaque texels are not affected. The value must not be negative. Defaults to <code>1.0f</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> float </td><td class="memItemRight bottomAlign"><span class="name"><b>alphaMultiplier</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAlphaMultiplier</b></span>(float <i>mult</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>alphaMultiplierChanged</b></span>(float <i>mult</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#preserveOpacity-prop">preserveOpacity</a> and <a href="qcustom3dvolume.html#textureData-prop">textureData</a>.</p>
<!-- @@@alphaMultiplier -->
<!-- $$$colorTable-prop$$$colorTable$$$setColorTableconstQVector<QRgb>&$$$colorTableChanged -->
<h3 class="fn" id="colorTable-prop"><a name="colorTable-prop"></a><span class="name">colorTable</span> : <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtgui/qcolor.html#QRgb-typedef">QRgb</a></span>&gt;</h3>
<p>The array containing the colors for indexed texture formats. If the texture format is not indexed, this array is not used and can be empty.</p>
<p>Defaults to <code>0</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVector&lt;QRgb&gt; </td><td class="memItemRight bottomAlign"><span class="name"><b>colorTable</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setColorTable</b></span>(const QVector&lt;QRgb&gt; &amp;<i>colors</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>colorTableChanged</b></span>()</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>(), and <a href="../qtgui/qimage.html#colorTable">QImage::colorTable</a>().</p>
<!-- @@@colorTable -->
<!-- $$$drawSliceFrames-prop$$$drawSliceFrames$$$setDrawSliceFramesbool$$$drawSliceFramesChangedbool -->
<h3 class="fn" id="drawSliceFrames-prop"><a name="drawSliceFrames-prop"></a><span class="name">drawSliceFrames</span> : <span class="type">bool</span></h3>
<p>If this property value is <code>true</code>, the frames of slices indicated by slice index properties will be drawn around the volume. If it is <code>false</code>, no slice frames will be drawn. Drawing slice frames is independent of drawing slices, so you can show the full volume and still draw the slice frames around it. This is useful when using <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>() to display the slices outside the graph itself. Defaults to <code>false</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>drawSliceFrames</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDrawSliceFrames</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>drawSliceFramesChanged</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#sliceIndexX-prop">sliceIndexX</a>, <a href="qcustom3dvolume.html#sliceIndexY-prop">sliceIndexY</a>, <a href="qcustom3dvolume.html#sliceIndexZ-prop">sliceIndexZ</a>, <a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a>, and <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>().</p>
<!-- @@@drawSliceFrames -->
<!-- $$$drawSlices-prop$$$drawSlices$$$setDrawSlicesbool$$$drawSlicesChangedbool -->
<h3 class="fn" id="drawSlices-prop"><a name="drawSlices-prop"></a><span class="name">drawSlices</span> : <span class="type">bool</span></h3>
<p>If this property value is <code>true</code>, the slices indicated by slice index properties will be drawn instead of the full volume. If it is <code>false</code>, the full volume will always be drawn. Defaults to <code>false</code>.</p>
<p><b>注:</b>The slices are always drawn along the item axes, so if the item is rotated, the slices are rotated as well.</p><p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>drawSlices</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDrawSlices</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>drawSlicesChanged</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#sliceIndexX-prop">sliceIndexX</a>, <a href="qcustom3dvolume.html#sliceIndexY-prop">sliceIndexY</a>, and <a href="qcustom3dvolume.html#sliceIndexZ-prop">sliceIndexZ</a>.</p>
<!-- @@@drawSlices -->
<!-- $$$preserveOpacity-prop$$$preserveOpacity$$$setPreserveOpacitybool$$$preserveOpacityChangedbool -->
<h3 class="fn" id="preserveOpacity-prop"><a name="preserveOpacity-prop"></a><span class="name">preserveOpacity</span> : <span class="type">bool</span></h3>
<p>If this property value is <code>true</code>, <a href="qcustom3dvolume.html#alphaMultiplier-prop">alphaMultiplier</a> is only applied to texels that already have some transparency. If it is <code>false</code>, the multiplier is applied to the alpha value of all texels. Defaults to <code>true</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>preserveOpacity</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setPreserveOpacity</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>preserveOpacityChanged</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#alphaMultiplier-prop">alphaMultiplier</a>.</p>
<!-- @@@preserveOpacity -->
<!-- $$$sliceFrameColor-prop$$$sliceFrameColor$$$setSliceFrameColorconstQColor&$$$sliceFrameColorChangedconstQColor& -->
<h3 class="fn" id="sliceFrameColor-prop"><a name="sliceFrameColor-prop"></a><span class="name">sliceFrameColor</span> : <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span></h3>
<p>Indicates the color of the slice frame. Transparent slice frame color is not supported.</p>
<p>Defaults to black.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QColor </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameColor</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceFrameColor</b></span>(const QColor &amp;<i>color</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameColorChanged</b></span>(const QColor &amp;<i>color</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceFrameColor -->
<!-- $$$sliceFrameGaps-prop$$$sliceFrameGaps$$$setSliceFrameGapsconstQVector3D&$$$sliceFrameGapsChangedconstQVector3D& -->
<h3 class="fn" id="sliceFrameGaps-prop"><a name="sliceFrameGaps-prop"></a><span class="name">sliceFrameGaps</span> : <span class="type"><a href="../qtgui/qvector3d.html">QVector3D</a></span></h3>
<p>Indicates the amount of air gap left between the volume itself and the frame in each dimension. The gap can be different on different dimensions. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</p>
<p>Defaults to <code>QVector3D(0.01, 0.01, 0.01)</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVector3D </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameGaps</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceFrameGaps</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameGapsChanged</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceFrameGaps -->
<!-- $$$sliceFrameThicknesses-prop$$$sliceFrameThicknesses$$$setSliceFrameThicknessesconstQVector3D&$$$sliceFrameThicknessesChangedconstQVector3D& -->
<h3 class="fn" id="sliceFrameThicknesses-prop"><a name="sliceFrameThicknesses-prop"></a><span class="name">sliceFrameThicknesses</span> : <span class="type"><a href="../qtgui/qvector3d.html">QVector3D</a></span></h3>
<p>Indicates the thickness of the slice frames for each dimension. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</p>
<p>Defaults to <code>QVector3D(0.01, 0.01, 0.01)</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVector3D </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameThicknesses</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceFrameThicknesses</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameThicknessesChanged</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceFrameThicknesses -->
<!-- $$$sliceFrameWidths-prop$$$sliceFrameWidths$$$setSliceFrameWidthsconstQVector3D&$$$sliceFrameWidthsChangedconstQVector3D& -->
<h3 class="fn" id="sliceFrameWidths-prop"><a name="sliceFrameWidths-prop"></a><span class="name">sliceFrameWidths</span> : <span class="type"><a href="../qtgui/qvector3d.html">QVector3D</a></span></h3>
<p>Indicates the widths of the slice frame. The width can be different on different dimensions, so you can for example omit drawing the frames on certain sides of the volume by setting the value for that dimension to zero. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</p>
<p>Defaults to <code>QVector3D(0.01, 0.01, 0.01)</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVector3D </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameWidths</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceFrameWidths</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceFrameWidthsChanged</b></span>(const QVector3D &amp;<i>values</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceFrameWidths -->
<!-- $$$sliceIndexX-prop$$$sliceIndexX$$$setSliceIndexXint$$$sliceIndexXChangedint -->
<h3 class="fn" id="sliceIndexX-prop"><a name="sliceIndexX-prop"></a><span class="name">sliceIndexX</span> : <span class="type">int</span></h3>
<p>The X dimension index into the texture data indicating which vertical slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to <code>-1</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexX</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceIndexX</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexXChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a>, and <a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceIndexX -->
<!-- $$$sliceIndexY-prop$$$sliceIndexY$$$setSliceIndexYint$$$sliceIndexYChangedint -->
<h3 class="fn" id="sliceIndexY-prop"><a name="sliceIndexY-prop"></a><span class="name">sliceIndexY</span> : <span class="type">int</span></h3>
<p>The Y dimension index into the texture data indicating which horizontal slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to <code>-1</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexY</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceIndexY</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexYChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a>, and <a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceIndexY -->
<!-- $$$sliceIndexZ-prop$$$sliceIndexZ$$$setSliceIndexZint$$$sliceIndexZChangedint -->
<h3 class="fn" id="sliceIndexZ-prop"><a name="sliceIndexZ-prop"></a><span class="name">sliceIndexZ</span> : <span class="type">int</span></h3>
<p>The Z dimension index into the texture data indicating which vertical slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to <code>-1</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexZ</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSliceIndexZ</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>sliceIndexZChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#drawSlices-prop">drawSlices</a>, and <a href="qcustom3dvolume.html#drawSliceFrames-prop">drawSliceFrames</a>.</p>
<!-- @@@sliceIndexZ -->
<!-- $$$textureData-prop$$$textureData$$$setTextureDataQVector<uchar>*$$$textureDataChangedQVector<uchar>* -->
<h3 class="fn" id="textureData-prop"><a name="textureData-prop"></a><span class="name">textureData</span> : <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtcore/qtglobal.html#uchar-typedef">uchar</a></span>&gt; *</h3>
<p>The array containing the texture data in the format specified by <a href="qcustom3dvolume.html#textureFormat">textureFormat</a>. The size of this array must be at least (<code>textureDataWidth * textureHeight * textureDepth * texture format color depth in bytes</code>).</p>
<p>A 3D texture is defined by a stack of 2D subtextures. Each subtexture must be of identical size (<code>textureDataWidth * textureHeight</code>), and the depth of the stack is defined by <a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a> property. Each 2D texture data is identical to a <a href="../qtgui/qimage.html">QImage</a> data with the same format, so <a href="../qtgui/qimage.html#bits">QImage::bits</a>() can be used to supply the data for each subtexture.</p>
<p>Ownership of the new array transfers to <a href="qcustom3dvolume.html">QCustom3DVolume</a> instance. If another array is set, the previous array is deleted. If the same array is set again, it is assumed that the array contents have been changed and the graph rendering is triggered.</p>
<p><b>注:</b>Each X-line of the data needs to be 32bit aligned. If the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> is <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> and <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a> is not divisible by four, padding bytes need to be added to each X-line of the <i>data</i>. You can get the padded byte count with <a href="qcustom3dvolume.html#textureDataWidth">textureDataWidth</a>() function. The padding bytes should indicate an fully transparent color to avoid rendering artifacts.</p><p>Defaults to <code>0</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVector&lt;uchar&gt; *</td><td class="memItemRight bottomAlign"><span class="name"><b>textureData</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTextureData</b></span>(QVector&lt;uchar&gt; *<i>data</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>textureDataChanged</b></span>(QVector&lt;uchar&gt; *<i>data</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#colorTable-prop">colorTable</a>, <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>(), <a href="qcustom3dvolume.html#setSubTextureData">setSubTextureData</a>(), and <a href="qcustom3dvolume.html#textureDataWidth">textureDataWidth</a>().</p>
<!-- @@@textureData -->
<!-- $$$textureDepth-prop$$$textureDepth$$$setTextureDepthint$$$textureDepthChangedint -->
<h3 class="fn" id="textureDepth-prop"><a name="textureDepth-prop"></a><span class="name">textureDepth</span> : <span class="type">int</span></h3>
<p>The depth of the 3D texture defining the volume content in pixels. Defaults to <code>0</code>.</p>
<p><b>注:</b>The <a href="qcustom3dvolume.html#textureData-prop">textureData</a> may need to be resized or recreated if this value is changed. Defaults to <code>0</code>.</p><p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>textureDepth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTextureDepth</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>textureDepthChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a>, <a href="qcustom3dvolume.html#textureHeight-prop">textureHeight</a>, and <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@textureDepth -->
<!-- $$$textureHeight-prop$$$textureHeight$$$setTextureHeightint$$$textureHeightChangedint -->
<h3 class="fn" id="textureHeight-prop"><a name="textureHeight-prop"></a><span class="name">textureHeight</span> : <span class="type">int</span></h3>
<p>The height of the 3D texture defining the volume content in pixels. Defaults to <code>0</code>.</p>
<p><b>注:</b>The <a href="qcustom3dvolume.html#textureData-prop">textureData</a> may need to be resized or recreated if this value is changed. Defaults to <code>0</code>.</p><p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>textureHeight</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTextureHeight</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>textureHeightChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a>, <a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a>, and <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@textureHeight -->
<!-- $$$textureWidth-prop$$$textureWidth$$$setTextureWidthint$$$textureWidthChangedint -->
<h3 class="fn" id="textureWidth-prop"><a name="textureWidth-prop"></a><span class="name">textureWidth</span> : <span class="type">int</span></h3>
<p>The width of the 3D texture defining the volume content in pixels. Defaults to <code>0</code>.</p>
<p><b>注:</b>The <a href="qcustom3dvolume.html#textureData-prop">textureData</a> may need to be resized or recreated if this value is changed. Defaults to <code>0</code>.</p><p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>textureWidth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTextureWidth</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>textureWidthChanged</b></span>(int <i>value</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#textureHeight-prop">textureHeight</a>, <a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a>, <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>(), and <a href="qcustom3dvolume.html#textureDataWidth">textureDataWidth</a>().</p>
<!-- @@@textureWidth -->
<!-- $$$useHighDefShader-prop$$$useHighDefShader$$$setUseHighDefShaderbool$$$useHighDefShaderChangedbool -->
<h3 class="fn" id="useHighDefShader-prop"><a name="useHighDefShader-prop"></a><span class="name">useHighDefShader</span> : <span class="type">bool</span></h3>
<p>If this property value is <code>true</code>, a high definition shader is used to render the volume. If it is <code>false</code>, a low definition shader is used.</p>
<p>The high definition shader guarantees that every visible texel of the volume texture is sampled when the volume is rendered. The low definition shader renders only a rough approximation of the volume contents, but at much higher frame rate. The low definition shader doesn't guarantee every texel of the volume texture is sampled, so there may be flickering if the volume contains distinct thin features.</p>
<p><b>注:</b>This value doesn't affect the level of detail when rendering the slices of the volume.</p><p>Defaults to <code>true</code>.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>useHighDefShader</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUseHighDefShader</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>useHighDefShaderChanged</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qcustom3dvolume.html#renderSlice">renderSlice</a>().</p>
<!-- @@@useHighDefShader -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$QCustom3DVolume[overload1]$$$QCustom3DVolumeQObject* -->
<h3 class="fn" id="QCustom3DVolume"><a name="QCustom3DVolume"></a>QCustom3DVolume::<span class="name">QCustom3DVolume</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = Q_NULLPTR)</h3>
<p>Constructs <a href="qcustom3dvolume.html">QCustom3DVolume</a> with given <i>parent</i>.</p>
<!-- @@@QCustom3DVolume -->
<!-- $$$QCustom3DVolume$$$QCustom3DVolumeconstQVector3D&constQVector3D&constQQuaternion&intintintQVector<uchar>*QImage::FormatconstQVector<QRgb>&QObject* -->
<h3 class="fn" id="QCustom3DVolume-1"><a name="QCustom3DVolume-1"></a>QCustom3DVolume::<span class="name">QCustom3DVolume</span>(const <span class="type"><a href="../qtgui/qvector3d.html">QVector3D</a></span> &amp;<i>position</i>, const <span class="type"><a href="../qtgui/qvector3d.html">QVector3D</a></span> &amp;<i>scaling</i>, const <span class="type"><a href="../qtgui/qquaternion.html">QQuaternion</a></span> &amp;<i>rotation</i>, <span class="type">int</span> <i>textureWidth</i>, <span class="type">int</span> <i>textureHeight</i>, <span class="type">int</span> <i>textureDepth</i>, <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtcore/qtglobal.html#uchar-typedef">uchar</a></span>&gt; *<i>textureData</i>, <span class="type"><a href="../qtgui/qimage.html#Format-enum">QImage::Format</a></span> <i>textureFormat</i>, const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtgui/qcolor.html#QRgb-typedef">QRgb</a></span>&gt; &amp;<i>colorTable</i>, <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = Q_NULLPTR)</h3>
<p>Constructs <a href="qcustom3dvolume.html">QCustom3DVolume</a> with given <i>position</i>, <i>scaling</i>, <i>rotation</i>, <i>textureWidth</i>, <i>textureHeight</i>, <i>textureDepth</i>, <i>textureData</i>, <i>textureFormat</i>, <i>colorTable</i>, and optional <i>parent</i>.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>(), and <a href="qcustom3dvolume.html#colorTable-prop">colorTable</a>.</p>
<!-- @@@QCustom3DVolume -->
<!-- $$$~QCustom3DVolume[overload1]$$$~QCustom3DVolume -->
<h3 class="fn" id="dtor.QCustom3DVolume"><a name="dtor.QCustom3DVolume"></a><code>[虚] </code>QCustom3DVolume::<span class="name">~QCustom3DVolume</span>()</h3>
<p>Destroys <a href="qcustom3dvolume.html">QCustom3DVolume</a>.</p>
<!-- @@@~QCustom3DVolume -->
<!-- $$$createTextureData[overload1]$$$createTextureDataconstQVector<QImage*>& -->
<h3 class="fn" id="createTextureData"><a name="createTextureData"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtcore/qtglobal.html#uchar-typedef">uchar</a></span>&gt; *QCustom3DVolume::<span class="name">createTextureData</span>(const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="../qtgui/qimage.html">QImage</a></span> *&gt; &amp;<i>images</i>)</h3>
<p>This function creates a new texture data array from an array of <i>images</i> and sets it as <a href="qcustom3dvolume.html#textureData-prop">textureData</a> for this volume object. The texture dimensions are also set according to image and array dimensions. All of the images in the array must be the same size. If the images are not all in <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> format, all texture data will be converted into <a href="../qtgui/qimage.html#Format-enum">QImage::Format_ARGB32</a> format. If the images are in <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> format, the <a href="qcustom3dvolume.html#colorTable-prop">colorTable</a> for the entire volume will be taken from the first image.</p>
<p>Returns pointer to the newly created array.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>, <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a>, <a href="qcustom3dvolume.html#textureHeight-prop">textureHeight</a>, <a href="qcustom3dvolume.html#textureDepth-prop">textureDepth</a>, and <a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@createTextureData -->
<!-- $$$renderSlice[overload1]$$$renderSliceQt::Axisint -->
<h3 class="fn" id="renderSlice"><a name="renderSlice"></a><span class="type"><a href="../qtgui/qimage.html">QImage</a></span> QCustom3DVolume::<span class="name">renderSlice</span>(<span class="type"><a href="../qtcore/qt.html#Axis-enum">Qt::Axis</a></span> <i>axis</i>, <span class="type">int</span> <i>index</i>)</h3>
<p>Renders the slice specified by <i>index</i> along <i>axis</i> into an image. The texture format of this object is used.</p>
<p>Returns the rendered image of the slice, or a null image if invalid index is specified.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@renderSlice -->
<!-- $$$setSliceIndices[overload1]$$$setSliceIndicesintintint -->
<h3 class="fn" id="setSliceIndices"><a name="setSliceIndices"></a><span class="type">void</span> QCustom3DVolume::<span class="name">setSliceIndices</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>z</i>)</h3>
<p>A convenience function for setting all three slice indices (<i>x</i>, <i>y</i>, and <i>z</i>) at once.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>.</p>
<!-- @@@setSliceIndices -->
<!-- $$$setSubTextureData[overload1]$$$setSubTextureDataQt::Axisintconstuchar* -->
<h3 class="fn" id="setSubTextureData"><a name="setSubTextureData"></a><span class="type">void</span> QCustom3DVolume::<span class="name">setSubTextureData</span>(<span class="type"><a href="../qtcore/qt.html#Axis-enum">Qt::Axis</a></span> <i>axis</i>, <span class="type">int</span> <i>index</i>, const <span class="type"><a href="../qtcore/qtglobal.html#uchar-typedef">uchar</a></span> *<i>data</i>)</h3>
<p>This function allows setting a single 2D subtexture of the 3D texture along the specified <i>axis</i> of the volume. The <i>index</i> parameter specifies the subtexture to set. The texture <i>data</i> must be in the format specified by <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> property and have size of the cross-section of the volume texture along the specified axis multiplied by the texture format color depth in bytes. The <i>data</i> is expected to be ordered similarly to the data in images produced by <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>() method along the same axis.</p>
<p><b>注:</b>Each X-line of the data needs to be 32bit aligned when targeting Y-axis or Z-axis. If the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> is <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> and <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a> is not divisible by four, padding bytes need to be added to each X-line of the <i>data</i> in cases it is not already properly aligned. The padding bytes should indicate an fully transparent color to avoid rendering artifacts.</p><p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a> and <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>().</p>
<!-- @@@setSubTextureData -->
<!-- $$$setSubTextureData$$$setSubTextureDataQt::AxisintconstQImage& -->
<h3 class="fn" id="setSubTextureData-1"><a name="setSubTextureData-1"></a><span class="type">void</span> QCustom3DVolume::<span class="name">setSubTextureData</span>(<span class="type"><a href="../qtcore/qt.html#Axis-enum">Qt::Axis</a></span> <i>axis</i>, <span class="type">int</span> <i>index</i>, const <span class="type"><a href="../qtgui/qimage.html">QImage</a></span> &amp;<i>image</i>)</h3>
<p>This function allows setting a single 2D subtexture of the 3D texture along the specified <i>axis</i> of the volume. The <i>index</i> parameter specifies the subtexture to set. The source <i>image</i> must be in the format specified by the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> property if the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> is indexed. If the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> is <a href="../qtgui/qimage.html#Format-enum">QImage::Format_ARGB32</a>, the image is converted to that format. The image must have the size of the cross-section of the volume texture along the specified axis. The orientation of the image should correspond to the orientation of the slice image produced by <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>() method along the same axis.</p>
<p><b>注:</b>Each X-line of the data needs to be 32bit aligned when targeting Y-axis or Z-axis. If the <a href="qcustom3dvolume.html#textureFormat">textureFormat</a> is <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> and <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a> is not divisible by four, padding bytes need to be added to each X-line of the <i>image</i> in cases it is not already properly aligned. The padding bytes should indicate an fully transparent color to avoid rendering artifacts. It is not guaranteed <a href="../qtgui/qimage.html">QImage</a> will do this automatically.</p><p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a> and <a href="qcustom3dvolume.html#renderSlice">renderSlice</a>().</p>
<!-- @@@setSubTextureData -->
<!-- $$$setTextureDimensions[overload1]$$$setTextureDimensionsintintint -->
<h3 class="fn" id="setTextureDimensions"><a name="setTextureDimensions"></a><span class="type">void</span> QCustom3DVolume::<span class="name">setTextureDimensions</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>)</h3>
<p>A convenience function for setting all three texture dimensions (<i>width</i>, <i>height</i>, and <i>depth</i>) at once.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureData-prop">textureData</a>.</p>
<!-- @@@setTextureDimensions -->
<!-- $$$setTextureFormat[overload1]$$$setTextureFormatQImage::Format -->
<h3 class="fn" id="setTextureFormat"><a name="setTextureFormat"></a><span class="type">void</span> QCustom3DVolume::<span class="name">setTextureFormat</span>(<span class="type"><a href="../qtgui/qimage.html#Format-enum">QImage::Format</a></span> <i>format</i>)</h3>
<p>Sets the format of the <a href="qcustom3dvolume.html#textureData-prop">textureData</a> to <i>format</i>. Only two formats are supported currently: <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a> and <a href="../qtgui/qimage.html#Format-enum">QImage::Format_ARGB32</a>. If an indexed format is specified, <a href="qcustom3dvolume.html#colorTable-prop">colorTable</a> must also be set. Defaults to <a href="../qtgui/qimage.html#Format-enum">QImage::Format_ARGB32</a>.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#textureFormat">textureFormat</a>(), <a href="qcustom3dvolume.html#colorTable-prop">colorTable</a>, and <a href="qcustom3dvolume.html#textureData-prop">textureData</a>.</p>
<!-- @@@setTextureFormat -->
<!-- $$$textureDataWidth[overload1]$$$textureDataWidth -->
<h3 class="fn" id="textureDataWidth"><a name="textureDataWidth"></a><span class="type">int</span> QCustom3DVolume::<span class="name">textureDataWidth</span>() const</h3>
<p>Returns the actual texture data width. When the texture format is <a href="../qtgui/qimage.html#Format-enum">QImage::Format_Indexed8</a>, this is <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a> aligned to 32bit boundary. Otherwise this is four times <a href="qcustom3dvolume.html#textureWidth-prop">textureWidth</a>.</p>
<!-- @@@textureDataWidth -->
<!-- $$$textureFormat[overload1]$$$textureFormat -->
<h3 class="fn" id="textureFormat"><a name="textureFormat"></a><span class="type"><a href="../qtgui/qimage.html#Format-enum">QImage::Format</a></span> QCustom3DVolume::<span class="name">textureFormat</span>() const</h3>
<p>Returns the format of the <a href="qcustom3dvolume.html#textureData-prop">textureData</a>.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@textureFormat -->
<!-- $$$textureFormatChanged[overload1]$$$textureFormatChangedQImage::Format -->
<h3 class="fn" id="textureFormatChanged"><a name="textureFormatChanged"></a><code>[信号] </code><span class="type">void</span> QCustom3DVolume::<span class="name">textureFormatChanged</span>(<span class="type"><a href="../qtgui/qimage.html#Format-enum">QImage::Format</a></span> <i>format</i>)</h3>
<p>This signal is emitted when the <a href="qcustom3dvolume.html#textureData-prop">textureData</a> <i>format</i> changes.</p>
<p><b>参照 </b><a href="qcustom3dvolume.html#setTextureFormat">setTextureFormat</a>().</p>
<!-- @@@textureFormatChanged -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
