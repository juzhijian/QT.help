<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qscxmlstatemachine.cpp -->
  <title>QScxmlStateMachine Class | Qt SCXML 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtscxml-index.html">Qt SCXML</a></td><td ><a href="qtscxml-module.html">C++ Classes</a></td><td >QScxmlStateMachine</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 参考文档</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公共函数</a></li>
<li class="level1"><a href="#public-slots">公共槽</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">详细描述</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QScxmlStateMachine Class</h1>
<!-- $$$QScxmlStateMachine-brief -->
<p>The <a href="qscxmlstatemachine.html">QScxmlStateMachine</a> class provides an interface to the state machines created from SCXML files. <a href="#details">更多...</a></p>
<!-- @@@QScxmlStateMachine -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QScxmlStateMachine&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += scxml</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.7</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a></td></tr></table></div><ul>
<li><a href="qscxmlstatemachine-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#BindingMethod-enum">BindingMethod</a></b> { EarlyBinding, LateBinding }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<ul>
<li class="fn"><b><a href="qscxmlstatemachine.html#dataModel-prop">dataModel</a></b> : QScxmlDataModel *</li>
<li class="fn"><b><a href="qscxmlstatemachine.html#initialValues-prop">initialValues</a></b> : QVariantMap</li>
<li class="fn"><b><a href="qscxmlstatemachine.html#initialized-prop">initialized</a></b> : const bool</li>
<li class="fn"><b><a href="qscxmlstatemachine.html#running-prop">running</a></b> : bool</li>
</ul>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公共函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#activeStateNames">activeStateNames</a></b>(bool <i>compress</i> = true) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#cancelDelayedEvent">cancelDelayedEvent</a></b>(const QString &amp;<i>sendId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaObject::Connection </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#connectToState">connectToState</a></b>(const QString &amp;<i>scxmlStateName</i>, const QObject *<i>receiver</i>, const char *<i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoConnection)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> BindingMethod </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#dataBinding">dataBinding</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScxmlDataModel *</td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#dataModel">dataModel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantMap </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#initialValues-prop">initialValues</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#isActive">isActive</a></b>(const QString &amp;<i>scxmlStateName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#isDispatchableTarget">isDispatchableTarget</a></b>(const QString &amp;<i>target</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#initialized-prop">isInitialized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#isInvoked">isInvoked</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#isRunning">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#name">name</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QScxmlError&gt; </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#parseErrors">parseErrors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScxmlEventFilter *</td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#scxmlEventFilter">scxmlEventFilter</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#sessionId">sessionId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#setDataModel">setDataModel</a></b>(QScxmlDataModel *<i>model</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#initialValues-prop">setInitialValues</a></b>(const QVariantMap &amp;<i>initialValues</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#setRunning">setRunning</a></b>(bool <i>running</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#setScxmlEventFilter">setScxmlEventFilter</a></b>(QScxmlEventFilter *<i>newFilter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#setSessionId">setSessionId</a></b>(const QString &amp;<i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#stateNames">stateNames</a></b>(bool <i>compress</i> = true) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#submitEvent">submitEvent</a></b>(QScxmlEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#submitEvent-1">submitEvent</a></b>(const QString &amp;<i>eventName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#submitEvent-2">submitEvent</a></b>(const QString &amp;<i>eventName</i>, const QVariant &amp;<i>data</i>)</td></tr>
</table></div>
<ul>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公共槽</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#init">init</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#start">start</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#stop">stop</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#dataModel-prop">dataModelChanged</a></b>(QScxmlDataModel *<i>model</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#eventOccurred">eventOccurred</a></b>(const QScxmlEvent &amp;<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#externalEventOccurred">externalEventOccurred</a></b>(const QScxmlEvent &amp;<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#finished">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#initialValues-prop">initialValuesChanged</a></b>(const QVariantMap &amp;<i>initialValues</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#initialized-prop">initializedChanged</a></b>(bool <i>initialized</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#log">log</a></b>(const QString &amp;<i>label</i>, const QString &amp;<i>msg</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#reachedStableState">reachedStableState</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#runningChanged">runningChanged</a></b>(bool <i>running</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QScxmlStateMachine *</td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#fromData">fromData</a></b>(QIODevice *<i>data</i>, const QString &amp;<i>fileName</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QScxmlStateMachine *</td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#fromFile">fromFile</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qscxmlstatemachine.html#generateSessionId">generateSessionId</a></b>(const QString &amp;<i>prefix</i>)</td></tr>
</table></div>
<ul>
<li class="fn">10 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<h3>附加的继承成员</h3>
<ul>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QScxmlStateMachine-description -->
<div class="descr">
<h2 id="details">详细描述</h2>
<p>The <a href="qscxmlstatemachine.html">QScxmlStateMachine</a> class provides an interface to the state machines created from SCXML files.</p>
<p><a href="qscxmlstatemachine.html">QScxmlStateMachine</a> is an implementation of the <a href="http://www.w3.org/TR/scxml/">State Chart XML (SCXML)</a>.</p>
<p>All states that are defined in the SCXML file are accessible as properties of <a href="qscxmlstatemachine.html">QScxmlStateMachine</a>. These properties are boolean values and indicate whether the state is active or inactive.</p>
<p>All external signals defined inside the SCXML file that are of the <code>qt:signal</code> type, are accessible as signals of <a href="qscxmlstatemachine.html">QScxmlStateMachine</a> in the <i>Qt mode</i>. The only argument of these signals is always <a href="../qtcore/qvariant.html">QVariant</a>, which is of <a href="../qtcore/qmap.html">QMap</a>&lt;<a href="../qtcore/qstring.html">QString</a>, <a href="../qtcore/qvariant.html">QVariant</a>&gt; type containing the content of all the <code>&lt;param&gt;</code> elements specified as children of a <code>&lt;send&gt;</code> element. The name of each <a href="qscxmlstatemachine.html">QScxmlStateMachine</a> signal corresponds to the value defined in the <i>event</i> attribute of one <code>&lt;send&gt;</code> tag in the SCXML file.</p>
</div>
<!-- @@@QScxmlStateMachine -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BindingMethod$$$EarlyBinding$$$LateBinding -->
<h3 class="fn" id="BindingMethod-enum"><a name="BindingMethod-enum"></a>enum QScxmlStateMachine::<span class="name">BindingMethod</span></h3>
<p>This enum specifies the binding method. The binding method controls the point in time when the initial values are assigned to the data elements.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QScxmlStateMachine::EarlyBinding</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">All data elements are created and initialized at data-model initialization. This is the default.</td></tr>
<tr><td class="topAlign"><code>QScxmlStateMachine::LateBinding</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">All data elements are created at initialization, but the initial values are assigned only when the containing state is entered for the first time. This is done before any executable content is executed.</td></tr>
</table></div>
<!-- @@@BindingMethod -->
</div>
<div class="prop">
<h2>属性文件</h2>
<!-- $$$dataModel-prop$$$dataModel$$$setDataModelQScxmlDataModel*$$$dataModelChangedQScxmlDataModel* -->
<h3 class="fn" id="dataModel-prop"><a name="dataModel-prop"></a><span class="name">dataModel</span> : <span class="type"><a href="qscxmldatamodel.html">QScxmlDataModel</a></span> *</h3>
<p>This property holds the data model to be used for this state machine.</p>
<p>SCXML data models are described in <a href="https://www.w3.org/TR/scxml/#data-module">SCXML Specification - 5 Data Model and Data Manipulation</a>. For more information about supported data models, see <a href="qtscxml-scxml-compliance.html">SCXML Compliance</a>.</p>
<p>Changing the data model when the state machine has been <code>initialized</code> is not specified in the SCXML standard and leads to undefined behavior.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QScxmlDataModel *</td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qscxmlstatemachine.html#dataModel">dataModel</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qscxmlstatemachine.html#setDataModel">setDataModel</a></b></span>(QScxmlDataModel *<i>model</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>dataModelChanged</b></span>(QScxmlDataModel *<i>model</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qscxmldatamodel.html">QScxmlDataModel</a>, <a href="qscxmlnulldatamodel.html">QScxmlNullDataModel</a>, <a href="qscxmlecmascriptdatamodel.html">QScxmlEcmaScriptDataModel</a>, and <a href="qscxmlcppdatamodel.html">QScxmlCppDataModel</a>.</p>
<!-- @@@dataModel -->
<!-- $$$initialValues-prop$$$initialValues$$$setInitialValuesconstQVariantMap&$$$initialValuesChangedconstQVariantMap& -->
<h3 class="fn" id="initialValues-prop"><a name="initialValues-prop"></a><span class="name">initialValues</span> : <span class="type"><a href="../qtcore/qvariant.html#QVariantMap-typedef">QVariantMap</a></span></h3>
<p>This property holds the initial values to be used for setting up the data model.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QVariantMap </td><td class="memItemRight bottomAlign"><span class="name"><b>initialValues</b></span>()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setInitialValues</b></span>(const QVariantMap &amp;<i>initialValues</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>initialValuesChanged</b></span>(const QVariantMap &amp;<i>initialValues</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qscxmlstatemachine.html#init">QScxmlStateMachine::init</a>() and <a href="qscxmldatamodel.html">QScxmlDataModel</a>.</p>
<!-- @@@initialValues -->
<!-- $$$initialized-prop$$$isInitialized$$$initializedChangedbool -->
<h3 class="fn" id="initialized-prop"><a name="initialized-prop"></a><span class="name">initialized</span> : const <span class="type">bool</span></h3>
<p>This property holds whether the state machine has been initialized.</p>
<p>It is <code>true</code> if the state machine has been initialized, <code>false</code> otherwise.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isInitialized</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>initializedChanged</b></span>(bool <i>initialized</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qscxmlstatemachine.html#init">QScxmlStateMachine::init</a>() and <a href="qscxmldatamodel.html">QScxmlDataModel</a>.</p>
<!-- @@@initialized -->
<!-- $$$running-prop$$$isRunning$$$setRunningbool$$$runningChangedbool -->
<h3 class="fn" id="running-prop"><a name="running-prop"></a><span class="name">running</span> : <span class="type">bool</span></h3>
<p>This property holds the running state of this state machine.</p>
<p><b>访问函数:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qscxmlstatemachine.html#isRunning">isRunning</a></b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qscxmlstatemachine.html#setRunning">setRunning</a></b></span>(bool <i>running</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qscxmlstatemachine.html#runningChanged">runningChanged</a></b></span>(bool <i>running</i>)</td></tr>
</table></div>
<p><b>参照 </b><a href="qscxmlstatemachine.html#start">start</a>().</p>
<!-- @@@running -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$activeStateNames[overload1]$$$activeStateNamesbool -->
<h3 class="fn" id="activeStateNames"><a name="activeStateNames"></a><span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> QScxmlStateMachine::<span class="name">activeStateNames</span>(<span class="type">bool</span> <i>compress</i> = true) const</h3>
<p>Retrieves a list of state names of all active states.</p>
<p>When a state is active, all its parent states are active by definition. When <i>compress</i> is <code>true</code> (the default), the parent states will be filtered out and only the <i>leaf states</i> will be returned. When it is <code>false</code>, the full list of active states will be returned.</p>
<!-- @@@activeStateNames -->
<!-- $$$cancelDelayedEvent[overload1]$$$cancelDelayedEventconstQString& -->
<h3 class="fn" id="cancelDelayedEvent"><a name="cancelDelayedEvent"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">cancelDelayedEvent</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>sendId</i>)</h3>
<p>Cancels a delayed event with the specified <i>sendId</i>.</p>
<!-- @@@cancelDelayedEvent -->
<!-- $$$connectToState[overload1]$$$connectToStateconstQString&constQObject*constchar*Qt::ConnectionType -->
<h3 class="fn" id="connectToState"><a name="connectToState"></a><span class="type"><a href="../qtcore/qmetaobject-connection.html">QMetaObject::Connection</a></span> QScxmlStateMachine::<span class="name">connectToState</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>scxmlStateName</i>, const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>receiver</i>, const <span class="type">char</span> *<i>method</i>, <span class="type"><a href="../qtcore/qt.html#ConnectionType-enum">Qt::ConnectionType</a></span> <i>type</i> = Qt::AutoConnection)</h3>
<p>Creates a connection of the given <i>type</i> from the state identified by <i>scxmlStateName</i> to the <i>method</i> in the <i>receiver</i> object. The receiver's <i>method</i> may contain a boolean argument that indicates whether the state connected became active or inactive.</p>
<p>Returns a handle to the connection, which can be used later to disconnect.</p>
<!-- @@@connectToState -->
<!-- $$$dataBinding[overload1]$$$dataBinding -->
<h3 class="fn" id="dataBinding"><a name="dataBinding"></a><span class="type"><a href="qscxmlstatemachine.html#BindingMethod-enum">BindingMethod</a></span> QScxmlStateMachine::<span class="name">dataBinding</span>() const</h3>
<p>Returns the binding method used by the state machine.</p>
<!-- @@@dataBinding -->
<!-- $$$dataModel -->
<h3 class="fn" id="dataModel"><a name="dataModel"></a><span class="type"><a href="qscxmldatamodel.html">QScxmlDataModel</a></span> *QScxmlStateMachine::<span class="name">dataModel</span>() const</h3>
<p>Returns the data model used by the state machine.</p>
<p><b>注:</b> Getter function for property <a href="qscxmlstatemachine.html#dataModel-prop">dataModel</a>. </p><p><b>参照 </b><a href="qscxmlstatemachine.html#setDataModel">setDataModel</a>().</p>
<!-- @@@dataModel -->
<!-- $$$eventOccurred[overload1]$$$eventOccurredconstQScxmlEvent& -->
<h3 class="fn" id="eventOccurred"><a name="eventOccurred"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">eventOccurred</span>(const <span class="type"><a href="qscxmlevent.html">QScxmlEvent</a></span> &amp;<i>event</i>)</h3>
<p>This signal is emitted when the SCXML event <i>event</i> occurs. This signal is emitted for all events.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#externalEventOccurred">externalEventOccurred</a>().</p>
<!-- @@@eventOccurred -->
<!-- $$$externalEventOccurred[overload1]$$$externalEventOccurredconstQScxmlEvent& -->
<h3 class="fn" id="externalEventOccurred"><a name="externalEventOccurred"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">externalEventOccurred</span>(const <span class="type"><a href="qscxmlevent.html">QScxmlEvent</a></span> &amp;<i>event</i>)</h3>
<p>This signal is emitted for each <code>&lt;send&gt;</code> element in the SCXML file that contains the attribute <code>type=&quot;qt:signal&quot;</code>. The event that occurred is specified by <i>event</i>.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#eventOccurred">eventOccurred</a>().</p>
<!-- @@@externalEventOccurred -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" id="finished"><a name="finished"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">finished</span>()</h3>
<p>This signal is emitted when the state machine reaches a top-level final state.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#running-prop">running</a>.</p>
<!-- @@@finished -->
<!-- $$$fromData[overload1]$$$fromDataQIODevice*constQString& -->
<h3 class="fn" id="fromData"><a name="fromData"></a><code>[static] </code><span class="type"><a href="qscxmlstatemachine.html">QScxmlStateMachine</a></span> *QScxmlStateMachine::<span class="name">fromData</span>(<span class="type"><a href="../qtcore/qiodevice.html">QIODevice</a></span> *<i>data</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>fileName</i> = QString())</h3>
<p>Creates a state machine by reading from the <a href="../qtcore/qiodevice.html">QIODevice</a> specified by <i>data</i>.</p>
<p>This method will always return a state machine. If errors occur while reading the SCXML file, <i>fileName</i>, the state machine cannot be started. The errors can be retrieved by calling the <a href="qscxmlstatemachine.html#parseErrors">parseErrors</a>() method.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#parseErrors">parseErrors</a>().</p>
<!-- @@@fromData -->
<!-- $$$fromFile[overload1]$$$fromFileconstQString& -->
<h3 class="fn" id="fromFile"><a name="fromFile"></a><code>[static] </code><span class="type"><a href="qscxmlstatemachine.html">QScxmlStateMachine</a></span> *QScxmlStateMachine::<span class="name">fromFile</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>fileName</i>)</h3>
<p>Creates a state machine from the SCXML file specified by <i>fileName</i>.</p>
<p>This method will always return a state machine. If errors occur while reading the SCXML file, the state machine cannot be started. The errors can be retrieved by calling the <a href="qscxmlstatemachine.html#parseErrors">parseErrors</a>() method.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#parseErrors">parseErrors</a>().</p>
<!-- @@@fromFile -->
<!-- $$$generateSessionId[overload1]$$$generateSessionIdconstQString& -->
<h3 class="fn" id="generateSessionId"><a name="generateSessionId"></a><code>[static] </code><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QScxmlStateMachine::<span class="name">generateSessionId</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>prefix</i>)</h3>
<p>Generates a unique ID by appending a unique number to the <i>prefix</i>.</p>
<p>The number is only unique within a single run of an application. This method is used when an invoked service does not have an ID set (the <i>id</i> attribute in <code>&lt;invoke&gt;</code>).</p>
<!-- @@@generateSessionId -->
<!-- $$$init[overload1]$$$init -->
<h3 class="fn" id="init"><a name="init"></a><code>[槽] </code><span class="type">bool</span> QScxmlStateMachine::<span class="name">init</span>()</h3>
<p>Initializes the state machine.</p>
<p>State machine initialization consists of calling <a href="qscxmldatamodel.html#setup">QScxmlDataModel::setup</a>(), setting the initial values for <code>&lt;data&gt;</code> elements, and executing any <code>&lt;script&gt;</code> tags of the <code>&lt;scxml&gt;</code> tag. The initial data values are taken from the <code>initialValues</code> property.</p>
<p>Returns <code>false</code> if parse errors occur or if any of the initialization steps fail. Returns <code>true</code> otherwise.</p>
<!-- @@@init -->
<!-- $$$isActive[overload1]$$$isActiveconstQString& -->
<h3 class="fn" id="isActive"><a name="isActive"></a><span class="type">bool</span> QScxmlStateMachine::<span class="name">isActive</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>scxmlStateName</i>) const</h3>
<p>Returns <code>true</code> if the state specified by <i>scxmlStateName</i> is active, <code>false</code> otherwise.</p>
<!-- @@@isActive -->
<!-- $$$isDispatchableTarget[overload1]$$$isDispatchableTargetconstQString& -->
<h3 class="fn" id="isDispatchableTarget"><a name="isDispatchableTarget"></a><span class="type">bool</span> QScxmlStateMachine::<span class="name">isDispatchableTarget</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>target</i>) const</h3>
<p>Returns <code>true</code> if a message to <i>target</i> can be dispatched by this state machine.</p>
<p>Valid targets are:</p>
<ul>
<li><code>#_parent</code> for the parent state machine if the current state machine is started by <code>&lt;invoke&gt;</code></li>
<li><code>#_internal</code> for the current state machine</li>
<li><code>#_scxml_sessionid</code>, where <code>sessionid</code> is the session ID of the current state machine</li>
<li><code>#_servicename</code>, where <code>servicename</code> is the ID or name of a service started with <code>&lt;invoke&gt;</code> by this state machine</li>
</ul>
<!-- @@@isDispatchableTarget -->
<!-- $$$isInvoked[overload1]$$$isInvoked -->
<h3 class="fn" id="isInvoked"><a name="isInvoked"></a><span class="type">bool</span> QScxmlStateMachine::<span class="name">isInvoked</span>() const</h3>
<p>Returns <code>true</code> when the state machine was started as a service with the <code>&lt;invoke&gt;</code> element, <code>false</code> otherwise.</p>
<!-- @@@isInvoked -->
<!-- $$$isRunning -->
<h3 class="fn" id="isRunning"><a name="isRunning"></a><span class="type">bool</span> QScxmlStateMachine::<span class="name">isRunning</span>() const</h3>
<p>Returns <code>true</code> if the state machine is running, <code>false</code> otherwise.</p>
<p><b>注:</b> Getter function for property <a href="qscxmlstatemachine.html#running-prop">running</a>. </p><p><b>参照 </b><a href="qscxmlstatemachine.html#setRunning">setRunning</a>() and <a href="qscxmlstatemachine.html#runningChanged">runningChanged</a>().</p>
<!-- @@@isRunning -->
<!-- $$$log[overload1]$$$logconstQString&constQString& -->
<h3 class="fn" id="log"><a name="log"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">log</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>label</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>msg</i>)</h3>
<p>This signal is emitted if a <code>&lt;log&gt;</code> tag is used in the SCXML. <i>label</i> is the value of the <i>label</i> attribute of the <code>&lt;log&gt;</code> tag. <i>msg</i> is the value of the evaluated <i>expr</i> attribute of the <code>&lt;log&gt;</code> tag. If there is no <i>expr</i> attribute, a null string will be returned.</p>
<!-- @@@log -->
<!-- $$$name[overload1]$$$name -->
<h3 class="fn" id="name"><a name="name"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QScxmlStateMachine::<span class="name">name</span>() const</h3>
<p>Returns the name of the state machine as set by the <i>name</i> attribute of the <code>&lt;scxml&gt;</code> tag.</p>
<!-- @@@name -->
<!-- $$$parseErrors[overload1]$$$parseErrors -->
<h3 class="fn" id="parseErrors"><a name="parseErrors"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qscxmlerror.html">QScxmlError</a></span>&gt; QScxmlStateMachine::<span class="name">parseErrors</span>() const</h3>
<p>Returns the list of parse errors that occurred while creating a state machine from an SCXML file.</p>
<!-- @@@parseErrors -->
<!-- $$$reachedStableState[overload1]$$$reachedStableState -->
<h3 class="fn" id="reachedStableState"><a name="reachedStableState"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">reachedStableState</span>()</h3>
<p>This signal is emitted when the event queue is empty at the end of a macro step or when a final state is reached.</p>
<!-- @@@reachedStableState -->
<!-- $$$runningChanged -->
<h3 class="fn" id="runningChanged"><a name="runningChanged"></a><code>[信号] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">runningChanged</span>(<span class="type">bool</span> <i>running</i>)</h3>
<p>This signal is emitted when the <code>running</code> property is changed with <i>running</i> as argument.</p>
<p><b>注:</b> 通知信号属性 <a href="qscxmlstatemachine.html#running-prop">running</a>. </p><!-- @@@runningChanged -->
<!-- $$$scxmlEventFilter[overload1]$$$scxmlEventFilter -->
<h3 class="fn" id="scxmlEventFilter"><a name="scxmlEventFilter"></a><span class="type"><a href="qscxmleventfilter.html">QScxmlEventFilter</a></span> *QScxmlStateMachine::<span class="name">scxmlEventFilter</span>() const</h3>
<p>Returns the SCXML event filter if one is set, otherwise returns null.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#setScxmlEventFilter">setScxmlEventFilter</a>().</p>
<!-- @@@scxmlEventFilter -->
<!-- $$$sessionId[overload1]$$$sessionId -->
<h3 class="fn" id="sessionId"><a name="sessionId"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QScxmlStateMachine::<span class="name">sessionId</span>() const</h3>
<p>Returns the session ID for the current state machine.</p>
<p>The session ID is used for message routing between parent and child state machines. If a state machine is started by an <code>&lt;invoke&gt;</code> element, any event it sends will have the <code>invokeid</code> field set to the session ID. The state machine will use the origin of an event (which is set by the <i>target</i> or <i>targetexpr</i> attribute in a <code>&lt;send&gt;</code> element) to dispatch messages to the correct child state machine.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#setSessionId">setSessionId</a>() and <a href="qscxmlevent.html#invokeId">QScxmlEvent::invokeId</a>().</p>
<!-- @@@sessionId -->
<!-- $$$setDataModel -->
<h3 class="fn" id="setDataModel"><a name="setDataModel"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">setDataModel</span>(<span class="type"><a href="qscxmldatamodel.html">QScxmlDataModel</a></span> *<i>model</i>)</h3>
<p>Sets the data model for this state machine to <i>model</i>. There is a 1:1 relation between state machines and models. After setting the model once you cannot change it anymore. Any further attempts to set the model using this method will be ignored.</p>
<p><b>注:</b> Setter function for property <a href="qscxmlstatemachine.html#dataModel-prop">dataModel</a>. </p><p><b>参照 </b><a href="qscxmlstatemachine.html#dataModel">dataModel</a>().</p>
<!-- @@@setDataModel -->
<!-- $$$setRunning -->
<h3 class="fn" id="setRunning"><a name="setRunning"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">setRunning</span>(<span class="type">bool</span> <i>running</i>)</h3>
<p>Starts the state machine if <i>running</i> is <code>true</code>, or stops it otherwise.</p>
<p><b>注:</b> Setter function for property <a href="qscxmlstatemachine.html#running-prop">running</a>. </p><p><b>参照 </b><a href="qscxmlstatemachine.html#start">start</a>(), <a href="qscxmlstatemachine.html#stop">stop</a>(), <a href="qscxmlstatemachine.html#isRunning">isRunning</a>(), and <a href="qscxmlstatemachine.html#runningChanged">runningChanged</a>().</p>
<!-- @@@setRunning -->
<!-- $$$setScxmlEventFilter[overload1]$$$setScxmlEventFilterQScxmlEventFilter* -->
<h3 class="fn" id="setScxmlEventFilter"><a name="setScxmlEventFilter"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">setScxmlEventFilter</span>(<span class="type"><a href="qscxmleventfilter.html">QScxmlEventFilter</a></span> *<i>newFilter</i>)</h3>
<p>Sets the <i>newFilter</i> as the SCXML event filter. Passing null will remove the current filter.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#scxmlEventFilter">scxmlEventFilter</a>().</p>
<!-- @@@setScxmlEventFilter -->
<!-- $$$setSessionId[overload1]$$$setSessionIdconstQString& -->
<h3 class="fn" id="setSessionId"><a name="setSessionId"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">setSessionId</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>id</i>)</h3>
<p>Sets the session ID for the current state machine to <i>id</i>.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#sessionId">sessionId</a>().</p>
<!-- @@@setSessionId -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" id="start"><a name="start"></a><code>[槽] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">start</span>()</h3>
<p>Starts this state machine. The machine will reset its configuration and transition to the initial state. When a final top-level state is entered, the machine will emit the <a href="qscxmlstatemachine.html#finished">finished</a>() signal.</p>
<p><b>注:</b>A state machine will not run without a running event loop, such as the main application event loop started with <a href="../qtcore/qcoreapplication.html#exec">QCoreApplication::exec</a>() or <a href="../qtwidgets/qapplication.html#exec">QApplication::exec</a>().</p><p><b>参照 </b><a href="qscxmlstatemachine.html#runningChanged">runningChanged</a>(), <a href="qscxmlstatemachine.html#setRunning">setRunning</a>(), <a href="qscxmlstatemachine.html#stop">stop</a>(), and <a href="qscxmlstatemachine.html#finished">finished</a>().</p>
<!-- @@@start -->
<!-- $$$stateNames[overload1]$$$stateNamesbool -->
<h3 class="fn" id="stateNames"><a name="stateNames"></a><span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> QScxmlStateMachine::<span class="name">stateNames</span>(<span class="type">bool</span> <i>compress</i> = true) const</h3>
<p>Retrieves a list of state names of all states.</p>
<p>When <i>compress</i> is <code>true</code> (the default), the states that contain child states will be filtered out and only the <i>leaf states</i> will be returned. When it is <code>false</code>, the full list of all states will be returned.</p>
<p>The returned list does not contain the states of possible nested state machines.</p>
<!-- @@@stateNames -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn" id="stop"><a name="stop"></a><code>[槽] </code><span class="type">void</span> QScxmlStateMachine::<span class="name">stop</span>()</h3>
<p>Stops this state machine. The machine will not execute any further state transitions. Its <code>running</code> property is set to <code>false</code>.</p>
<p><b>参照 </b><a href="qscxmlstatemachine.html#runningChanged">runningChanged</a>(), <a href="qscxmlstatemachine.html#start">start</a>(), and <a href="qscxmlstatemachine.html#setRunning">setRunning</a>().</p>
<!-- @@@stop -->
<!-- $$$submitEvent[overload1]$$$submitEventQScxmlEvent* -->
<h3 class="fn" id="submitEvent"><a name="submitEvent"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">submitEvent</span>(<span class="type"><a href="qscxmlevent.html">QScxmlEvent</a></span> *<i>event</i>)</h3>
<p>Submits the SCXML event <i>event</i> to the internal or external event queue depending on the priority of the event.</p>
<p>When a delay is set, the event will be queued for delivery after the timeout has passed.</p>
<!-- @@@submitEvent -->
<!-- $$$submitEvent$$$submitEventconstQString& -->
<h3 class="fn" id="submitEvent-1"><a name="submitEvent-1"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">submitEvent</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>eventName</i>)</h3>
<p>A utility method to create and submit an external event with the specified <i>eventName</i> as the name.</p>
<!-- @@@submitEvent -->
<!-- $$$submitEvent$$$submitEventconstQString&constQVariant& -->
<h3 class="fn" id="submitEvent-2"><a name="submitEvent-2"></a><span class="type">void</span> QScxmlStateMachine::<span class="name">submitEvent</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>eventName</i>, const <span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> &amp;<i>data</i>)</h3>
<p>A utility method to create and submit an external event with the specified <i>eventName</i> as the name and <i>data</i> as the payload data.</p>
<!-- @@@submitEvent -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
