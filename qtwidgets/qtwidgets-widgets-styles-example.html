<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- styles.qdoc -->
  <title>Styles Example | Qt Widgets 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtwidgets-index.html">Qt Widgets</a></td><td >Styles Example</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#norwegianwoodstyle-class-definition">NorwegianWoodStyle Class Definition</a></li>
<li class="level1"><a href="#norwegianwoodstyle-class-implementation">NorwegianWoodStyle Class Implementation</a></li>
<li class="level1"><a href="#widgetgallery-class">WidgetGallery Class</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Styles Example</h1>
<span class="subtitle"></span>
<!-- $$$widgets/styles-description -->
<div class="descr"> <a name="details"></a>
<p class="centerAlign"><img src="images/styles-enabledwood.png" alt="Screenshot of the Styles example" /></p><p>A style in Qt is a subclass of <a href="qstyle.html">QStyle</a> or of one of its subclasses. Styles perform drawing on behalf of widgets. Qt provides a whole range of predefined styles, either built into the Qt Widgets module or found in plugins. Styles are usually customized by subclassing <a href="qproxystyle.html">QProxyStyle</a> and reimplementing a few virtual functions. While <a href="qproxystyle.html">QProxyStyle</a> provides a transparent way to customize either a specific style or the appropriate platform's default style, Qt also provides <a href="qcommonstyle.html">QCommonStyle</a> as a convenient base for full custom style implementations.</p>
<p>In this example, the custom style is called <code>NorwegianWoodStyle</code> and derives from <a href="qproxystyle.html">QProxyStyle</a>. Its main features are the wooden textures used for filling most of the widgets and its round buttons and comboboxes.</p>
<p>To implement the style, we use some advanced features provided by <a href="../qtgui/qpainter.html">QPainter</a>, such as <a href="../qtgui/qpainter.html#RenderHint-enum">antialiasing</a> (to obtain smoother button edges), <a href="../qtgui/qcolor.html#alpha">alpha blending</a> (to make the buttons appeared raised or sunken), and <a href="../qtgui/qpainterpath.html">painter paths</a> (to fill the buttons and draw the outline). We also use many features of <a href="../qtgui/qbrush.html">QBrush</a> and <a href="../qtgui/qpalette.html">QPalette</a>.</p>
<p>The example consists of the following classes:</p>
<ul>
<li><code>NorwegianWoodStyle</code> inherits from <a href="qproxystyle.html">QProxyStyle</a> and implements the Norwegian Wood style.</li>
<li><code>WidgetGallery</code> is a <code>QDialog</code> subclass that shows the most common widgets and allows the user to switch style dynamically.</li>
</ul>
<a name="norwegianwoodstyle-class-definition"></a>
<h2 id="norwegianwoodstyle-class-definition">NorwegianWoodStyle Class Definition</h2>
<p>Here's the definition of the <code>NorwegianWoodStyle</code> class:</p>
<pre class="cpp">

  <span class="keyword">class</span> NorwegianWoodStyle : <span class="keyword">public</span> <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      NorwegianWoodStyle();

      <span class="type">void</span> polish(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span> <span class="operator">&amp;</span>palette) Q_DECL_OVERRIDE;
      <span class="type">void</span> polish(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) Q_DECL_OVERRIDE;
      <span class="type">void</span> unpolish(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) Q_DECL_OVERRIDE;
      <span class="type">int</span> pixelMetric(PixelMetric metric<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                      <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span> Q_DECL_OVERRIDE;
      <span class="type">int</span> styleHint(StyleHint hint<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                    <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget<span class="operator">,</span> <span class="type"><a href="qstylehintreturn.html">QStyleHintReturn</a></span> <span class="operator">*</span>returnData) <span class="keyword">const</span> Q_DECL_OVERRIDE;
      <span class="type">void</span> drawPrimitive(PrimitiveElement element<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                         <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span> Q_DECL_OVERRIDE;
      <span class="type">void</span> drawControl(ControlElement control<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                       <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span> Q_DECL_OVERRIDE;

  <span class="keyword">private</span>:
      <span class="keyword">static</span> <span class="type">void</span> setTexture(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span> <span class="operator">&amp;</span>palette<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ColorRole role<span class="operator">,</span>
                             <span class="keyword">const</span> <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> <span class="operator">&amp;</span>pixmap);
      <span class="keyword">static</span> <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> roundRectPath(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> <span class="operator">&amp;</span>rect);
  };

</pre>
<p>The public functions are all declared in <a href="qstyle.html">QStyle</a> (<a href="qproxystyle.html">QProxyStyle</a>'s grandparent class) and reimplemented here to override the Windows look and feel. The private functions are helper functions.</p>
<a name="norwegianwoodstyle-class-implementation"></a>
<h2 id="norwegianwoodstyle-class-implementation">NorwegianWoodStyle Class Implementation</h2>
<p>We will now review the implementation of the <code>NorwegianWoodStyle</code> class.</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>polish(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span> <span class="operator">&amp;</span>palette)
  {
      <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> brown(<span class="number">212</span><span class="operator">,</span> <span class="number">140</span><span class="operator">,</span> <span class="number">95</span>);
      <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> beige(<span class="number">236</span><span class="operator">,</span> <span class="number">182</span><span class="operator">,</span> <span class="number">120</span>);
      <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> slightlyOpaqueBlack(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">63</span>);

      <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> backgroundImage(<span class="string">&quot;:/images/woodbackground.png&quot;</span>);
      <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> buttonImage(<span class="string">&quot;:/images/woodbutton.png&quot;</span>);
      <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> midImage <span class="operator">=</span> buttonImage;

      <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> painter;
      painter<span class="operator">.</span>begin(<span class="operator">&amp;</span>midImage);
      painter<span class="operator">.</span>setPen(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>NoPen);
      painter<span class="operator">.</span>fillRect(midImage<span class="operator">.</span>rect()<span class="operator">,</span> slightlyOpaqueBlack);
      painter<span class="operator">.</span>end();

</pre>
<p>The <code>polish()</code> function is reimplemented from <a href="qstyle.html">QStyle</a>. It takes a <a href="../qtgui/qpalette.html">QPalette</a> as a reference and adapts the palette to fit the style. Most styles don't need to reimplement that function. The Norwegian Wood style reimplements it to set a &quot;wooden&quot; palette.</p>
<p>We start by defining a few <a href="../qtgui/qcolor.html">QColor</a>s that we'll need. Then we load two PNG images. The <code>:</code> prefix in the file path indicates that the PNG files are <a href="../qtcore/resources.html">embedded resources</a>.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><img src="images/woodbackground.png" alt="" /></td><td ><b>woodbackground.png</b><p>This texture is used as the background of most widgets. The wood pattern is horizontal.</p>
</td></tr>
<tr valign="top" class="even"><td ><img src="images/woodbutton.png" alt="" /></td><td ><b>woodbutton.png</b><p>This texture is used for filling push buttons and comboboxes. The wood pattern is vertical and more reddish than the texture used for the background.</p>
</td></tr>
</table></div>
<p>The <code>midImage</code> variable is initialized to be the same as <code>buttonImage</code>, but then we use a <a href="../qtgui/qpainter.html">QPainter</a> and fill it with a 25% opaque black color (a black with an <a href="../qtgui/qcolor.html#alpha">alpha channel</a> of 63). The result is a somewhat darker image than <code>buttonImage</code>. This image will be used for filling buttons that the user is holding down.</p>
<pre class="cpp">

      palette <span class="operator">=</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span>(brown);

      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>BrightText<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>white);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Base<span class="operator">,</span> beige);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Highlight<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>darkGreen);
      setTexture(palette<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Button<span class="operator">,</span> buttonImage);
      setTexture(palette<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Mid<span class="operator">,</span> midImage);
      setTexture(palette<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Window<span class="operator">,</span> backgroundImage);

      <span class="type"><a href="../qtgui/qbrush.html">QBrush</a></span> brush <span class="operator">=</span> palette<span class="operator">.</span>background();
      brush<span class="operator">.</span>setColor(brush<span class="operator">.</span>color()<span class="operator">.</span>dark());

      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>WindowText<span class="operator">,</span> brush);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Text<span class="operator">,</span> brush);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ButtonText<span class="operator">,</span> brush);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Base<span class="operator">,</span> brush);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Button<span class="operator">,</span> brush);
      palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Mid<span class="operator">,</span> brush);
  }

</pre>
<p>We initialize the palette. Palettes have various <a href="../qtgui/qpalette.html#ColorRole-enum">color roles</a>, such as <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Base</a> (used for filling text editors, item views, etc.), <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Text</a> (used for foreground text), and <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Background</a> (used for the background of most widgets). Each role has its own <a href="../qtgui/qbrush.html">QBrush</a>, which usually is a plain color but can also be a brush pattern or even a texture (a <a href="../qtgui/qpixmap.html">QPixmap</a>).</p>
<p>In addition to the roles, palettes have several <a href="../qtgui/qpalette.html#ColorGroup-enum">color groups</a>: active, disabled, and inactive. The active color group is used for painting widgets in the active window. The disabled group is used for disabled widgets. The inactive group is used for all other widgets. Most palettes have identical active and inactive groups, while the disabled group uses darker shades.</p>
<p>We initialize the <a href="../qtgui/qpalette.html">QPalette</a> object with a brown color. Qt automatically derivates all color roles for all color groups from that single color. We then override some of the default values. For example, we use <a href="../qtcore/qt.html#GlobalColor-enum">Qt::darkGreen</a> instead of the default (<a href="../qtcore/qt.html#GlobalColor-enum">Qt::darkBlue</a>) for the <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Highlight</a> role. The <a href="../qtgui/qpalette.html#setBrush-1">QPalette::setBrush</a>() overload that we use here sets the same color or brush for all three color groups.</p>
<p>The <code>setTexture()</code> function is a private function that sets the texture for a certain color role, while preserving the existing color in the <a href="../qtgui/qbrush.html">QBrush</a>. A <a href="../qtgui/qbrush.html">QBrush</a> can hold both a solid color and a texture at the same time. The solid color is used for drawing text and other graphical elements where textures don't look good.</p>
<p>At the end, we set the brush for the disabled color group of the palette. We use <code>woodbackground.png</code> as the texture for all disabled widgets, including buttons, and use a darker color to accompany the texture.</p>
<p class="centerAlign"><img src="images/styles-disabledwood.png" alt="The Norwegian Wood style with disabled widgets" /></p><p>Let's move on to the other functions reimplemented from <a href="qproxystyle.html">QProxyStyle</a>:</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>polish(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget)
  {
      <span class="keyword">if</span> (qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qpushbutton.html">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(widget)
              <span class="operator">|</span><span class="operator">|</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qcombobox.html">QComboBox</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(widget))
          widget<span class="operator">-</span><span class="operator">&gt;</span>setAttribute(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>WA_Hover<span class="operator">,</span> <span class="keyword">true</span>);
  }

</pre>
<p>This <a href="qstyle.html#polish">QStyle::polish</a>() overload is called once on every widget drawn using the style. We reimplement it to set the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_Hover</a> attribute on <a href="qpushbutton.html">QPushButton</a>s and <a href="qcombobox.html">QComboBox</a>es. When this attribute is set, Qt generates paint events when the mouse pointer enters or leaves the widget. This makes it possible to render push buttons and comboboxes differently when the mouse pointer is over them.</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>unpolish(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget)
  {
      <span class="keyword">if</span> (qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qpushbutton.html">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(widget)
              <span class="operator">|</span><span class="operator">|</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qcombobox.html">QComboBox</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(widget))
          widget<span class="operator">-</span><span class="operator">&gt;</span>setAttribute(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>WA_Hover<span class="operator">,</span> <span class="keyword">false</span>);
  }

</pre>
<p>This <a href="qstyle.html#unpolish">QStyle::unpolish</a>() overload is called to undo any modification done to the widget in <code>polish()</code>. For simplicity, we assume that the flag wasn't set before <code>polish()</code> was called. In an ideal world, we would remember the original state for each widgets (e.g&#x2e;, using a <a href="../qtcore/qmap.html">QMap</a>&lt;<a href="qwidget.html">QWidget</a> *, bool&gt;) and restore it in <code>unpolish()</code>.</p>
<pre class="cpp">

  <span class="type">int</span> NorwegianWoodStyle<span class="operator">::</span>pixelMetric(PixelMetric metric<span class="operator">,</span>
                                      <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                                      <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span>
  {
      <span class="keyword">switch</span> (metric) {
      <span class="keyword">case</span> PM_ComboBoxFrameWidth:
          <span class="keyword">return</span> <span class="number">8</span>;
      <span class="keyword">case</span> PM_ScrollBarExtent:
          <span class="keyword">return</span> <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>pixelMetric(metric<span class="operator">,</span> option<span class="operator">,</span> widget) <span class="operator">+</span> <span class="number">4</span>;
      <span class="keyword">default</span>:
          <span class="keyword">return</span> <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>pixelMetric(metric<span class="operator">,</span> option<span class="operator">,</span> widget);
      }
  }

</pre>
<p>The <a href="qstyle.html#pixelMetric">pixelMetric()</a> function returns the size in pixels for a certain user interface element. By reimplementing this function, we can affect the way certain widgets are drawn and their size hint. Here, we return 8 as the width around a shown in a <a href="qcombobox.html">QComboBox</a>, ensuring that there is enough place around the text and the arrow for the Norwegian Wood round corners. The default value for this setting in the Windows style is 2.</p>
<p>We also change the extent of <a href="qscrollbar.html">QScrollBar</a>s, i.e&#x2e;, the height for a horizontal scroll bar and the width for a vertical scroll bar, to be 4 pixels more than in the Windows style. This makes the style a bit more distinctive.</p>
<p>For all other <a href="qstyle.html#PixelMetric-enum">QStyle::PixelMetric</a> elements, we use the Windows settings.</p>
<pre class="cpp">

  <span class="type">int</span> NorwegianWoodStyle<span class="operator">::</span>styleHint(StyleHint hint<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                                    <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget<span class="operator">,</span>
                                    <span class="type"><a href="qstylehintreturn.html">QStyleHintReturn</a></span> <span class="operator">*</span>returnData) <span class="keyword">const</span>
  {
      <span class="keyword">switch</span> (hint) {
      <span class="keyword">case</span> SH_DitherDisabledText:
          <span class="keyword">return</span> <span class="type">int</span>(<span class="keyword">false</span>);
      <span class="keyword">case</span> SH_EtchDisabledText:
          <span class="keyword">return</span> <span class="type">int</span>(<span class="keyword">true</span>);
      <span class="keyword">default</span>:
          <span class="keyword">return</span> <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>styleHint(hint<span class="operator">,</span> option<span class="operator">,</span> widget<span class="operator">,</span> returnData);
      }
  }

</pre>
<p>The <a href="qstyle.html#styleHint">styleHint()</a> function returns some hints to widgets or to the base style (in our case <a href="qproxystyle.html">QProxyStyle</a>) about how to draw the widgets. The Windows style returns <code>true</code> for the <a href="qstyle.html#StyleHint-enum">QStyle::SH_DitherDisabledText</a> hint, resulting in a most unpleasing visual effect. We override this behavior and return <code>false</code> instead. We also return <code>true</code> for the <a href="qstyle.html#StyleHint-enum">QStyle::SH_EtchDisabledText</a> hint, meaning that disabled text is rendered with an embossed look.</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>drawPrimitive(PrimitiveElement element<span class="operator">,</span>
                                         <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                                         <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span>
                                         <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span>
  {
      <span class="keyword">switch</span> (element) {
      <span class="keyword">case</span> PE_PanelButtonCommand:
          {
              <span class="type">int</span> delta <span class="operator">=</span> (option<span class="operator">-</span><span class="operator">&gt;</span>state <span class="operator">&amp;</span> State_MouseOver) <span class="operator">?</span> <span class="number">64</span> : <span class="number">0</span>;
              <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> slightlyOpaqueBlack(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">63</span>);
              <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> semiTransparentWhite(<span class="number">255</span><span class="operator">,</span> <span class="number">255</span><span class="operator">,</span> <span class="number">255</span><span class="operator">,</span> <span class="number">127</span> <span class="operator">+</span> delta);
              <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> semiTransparentBlack(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">127</span> <span class="operator">-</span> delta);

              <span class="type">int</span> x<span class="operator">,</span> y<span class="operator">,</span> width<span class="operator">,</span> height;
              option<span class="operator">-</span><span class="operator">&gt;</span>rect<span class="operator">.</span>getRect(<span class="operator">&amp;</span>x<span class="operator">,</span> <span class="operator">&amp;</span>y<span class="operator">,</span> <span class="operator">&amp;</span>width<span class="operator">,</span> <span class="operator">&amp;</span>height);

</pre>
<p>The <a href="qstyle.html#drawPrimitive">drawPrimitive()</a> function is called by Qt widgets to draw various fundamental graphical elements. Here we reimplement it to draw <a href="qpushbutton.html">QPushButton</a> and <a href="qcombobox.html">QComboBox</a> with round corners. The button part of these widgets is drawn using the <a href="qstyle.html#PrimitiveElement-enum">QStyle::PE_PanelButtonCommand</a> primitive element.</p>
<p>The <code>option</code> parameter, of type <a href="qstyleoption.html">QStyleOption</a>, contains everything we need to know about the widget we want to draw on. In particular, <code>option-&gt;rect</code> gives the rectangle within which to draw the primitive element. The <code>painter</code> parameter is a <a href="../qtgui/qpainter.html">QPainter</a> object that we can use to draw on the widget.</p>
<p>The <code>widget</code> parameter is the widget itself. Normally, all the information we need is available in <code>option</code> and <code>painter</code>, so we don't need <code>widget</code>. We can use it to perform special effects; for example, QMacStyle uses it to animate default buttons. If you use it, be aware that the caller is allowed to pass a null pointer.</p>
<p>We start by defining three <a href="../qtgui/qcolor.html">QColor</a>s that we'll need later on. We also put the x, y, width, and height components of the widget's rectangle in local variables. The value used for the <code>semiTransparentWhite</code> and for the <code>semiTransparentBlack</code> color's alpha channel depends on whether the mouse cursor is over the widget or not. Since we set the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_Hover</a> attribute on <a href="qpushbutton.html">QPushButton</a>s and <a href="qcombobox.html">QComboBox</a>es, we can rely on the <a href="qstyle.html#StateFlag-enum">QStyle::State_MouseOver</a> flag to be set when the mouse is over the widget.</p>
<pre class="cpp">

              <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> roundRect <span class="operator">=</span> roundRectPath(option<span class="operator">-</span><span class="operator">&gt;</span>rect);
              <span class="type">int</span> radius <span class="operator">=</span> <a href="../qtcore/qtglobal.html#qMin">qMin</a>(width<span class="operator">,</span> height) <span class="operator">/</span> <span class="number">2</span>;

</pre>
<p>The <code>roundRect</code> variable is a <a href="../qtgui/qpainterpath.html">QPainterPath</a>. A <a href="../qtgui/qpainterpath.html">QPainterPath</a> is is a vectorial specification of a shape. Any shape (rectangle, ellipse, spline, etc.) or combination of shapes can be expressed as a path. We will use <code>roundRect</code> both for filling the button background with a wooden texture and for drawing the outline. The <code>roundRectPath()</code> function is a private function; we will come back to it later.</p>
<pre class="cpp">

              <span class="type"><a href="../qtgui/qbrush.html">QBrush</a></span> brush;
              bool darker;

              <span class="keyword">const</span> <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span> <span class="operator">*</span>buttonOption <span class="operator">=</span>
                      qstyleoption_cast<span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(option);
              <span class="keyword">if</span> (buttonOption
                      <span class="operator">&amp;</span><span class="operator">&amp;</span> (buttonOption<span class="operator">-</span><span class="operator">&gt;</span>features <span class="operator">&amp;</span> <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span><span class="operator">::</span>Flat)) {
                  brush <span class="operator">=</span> option<span class="operator">-</span><span class="operator">&gt;</span>palette<span class="operator">.</span>background();
                  darker <span class="operator">=</span> (option<span class="operator">-</span><span class="operator">&gt;</span>state <span class="operator">&amp;</span> (State_Sunken <span class="operator">|</span> State_On));
              } <span class="keyword">else</span> {
                  <span class="keyword">if</span> (option<span class="operator">-</span><span class="operator">&gt;</span>state <span class="operator">&amp;</span> (State_Sunken <span class="operator">|</span> State_On)) {
                      brush <span class="operator">=</span> option<span class="operator">-</span><span class="operator">&gt;</span>palette<span class="operator">.</span>mid();
                      darker <span class="operator">=</span> <span class="operator">!</span>(option<span class="operator">-</span><span class="operator">&gt;</span>state <span class="operator">&amp;</span> State_Sunken);
                  } <span class="keyword">else</span> {
                      brush <span class="operator">=</span> option<span class="operator">-</span><span class="operator">&gt;</span>palette<span class="operator">.</span>button();
                      darker <span class="operator">=</span> <span class="keyword">false</span>;
                  }
              }

</pre>
<p>We define two variables, <code>brush</code> and <code>darker</code>, and initialize them based on the state of the button:</p>
<ul>
<li>If the button is a <a href="qpushbutton.html#flat-prop">flat button</a>, we use the <a href="../qtgui/qpalette.html#ColorRole-enum">Background</a> brush. We set <code>darker</code> to <code>true</code> if the button is <a href="qabstractbutton.html#down-prop">down</a> or <a href="qabstractbutton.html#checked-prop">checked</a>.</li>
<li>If the button is currently held down by the user or in the <a href="qabstractbutton.html#checked-prop">checked</a> state, we use the <a href="../qtgui/qpalette.html#ColorRole-enum">Mid</a> component of the palette. We set <code>darker</code> to <code>true</code> if the button is <a href="qabstractbutton.html#checked-prop">checked</a>.</li>
<li>Otherwise, we use the <a href="../qtgui/qpalette.html#ColorRole-enum">Button</a> component of the palette.</li>
</ul>
<p>The screenshot below illustrates how <a href="qpushbutton.html">QPushButton</a>s are rendered based on their state:</p>
<p class="centerAlign"><img src="images/styles-woodbuttons.png" alt="Norwegian Wood buttons in different states" /></p><p>To discover whether the button is flat or not, we need to cast the <code>option</code> parameter to <a href="qstyleoptionbutton.html">QStyleOptionButton</a> and check if the <a href="qstyleoptionbutton.html#features-var">features</a> member specifies the <a href="qstyleoptionbutton.html#ButtonFeature-enum">QStyleOptionButton::Flat</a> flag. The <a href="qstyleoption.html#qstyleoption_cast">qstyleoption_cast</a>() function performs a dynamic cast; if <code>option</code> is not a <a href="qstyleoptionbutton.html">QStyleOptionButton</a>, <a href="qstyleoption.html#qstyleoption_cast">qstyleoption_cast</a>() returns a null pointer.</p>
<pre class="cpp">

              painter<span class="operator">-</span><span class="operator">&gt;</span>save();
              painter<span class="operator">-</span><span class="operator">&gt;</span>setRenderHint(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span><span class="operator">::</span>Antialiasing<span class="operator">,</span> <span class="keyword">true</span>);
              painter<span class="operator">-</span><span class="operator">&gt;</span>fillPath(roundRect<span class="operator">,</span> brush);
              <span class="keyword">if</span> (darker)
                  painter<span class="operator">-</span><span class="operator">&gt;</span>fillPath(roundRect<span class="operator">,</span> slightlyOpaqueBlack);

</pre>
<p>We turn on antialiasing on <a href="../qtgui/qpainter.html">QPainter</a>. Antialiasing is a technique that reduces the visual distortion that occurs when the edges of a shape are converted into pixels. For the Norwegian Wood style, we use it to obtain smoother edges for the round buttons.</p>
<p class="centerAlign"><img src="images/styles-aliasing.png" alt="Norwegian wood buttons with and without antialiasing" /></p><p>The first call to <a href="../qtgui/qpainter.html#fillPath">QPainter::fillPath</a>() draws the background of the button with a wooden texture. The second call to <a href="../qtgui/qpainter.html#fillPath">fillPath()</a> paints the same area with a semi-transparent black color (a black color with an alpha channel of 63) to make the area darker if <code>darker</code> is true.</p>
<pre class="cpp">

              <span class="type">int</span> penWidth;
              <span class="keyword">if</span> (radius <span class="operator">&lt;</span> <span class="number">10</span>)
                  penWidth <span class="operator">=</span> <span class="number">3</span>;
              <span class="keyword">else</span> <span class="keyword">if</span> (radius <span class="operator">&lt;</span> <span class="number">20</span>)
                  penWidth <span class="operator">=</span> <span class="number">5</span>;
              <span class="keyword">else</span>
                  penWidth <span class="operator">=</span> <span class="number">7</span>;

              <span class="type"><a href="../qtgui/qpen.html">QPen</a></span> topPen(semiTransparentWhite<span class="operator">,</span> penWidth);
              <span class="type"><a href="../qtgui/qpen.html">QPen</a></span> bottomPen(semiTransparentBlack<span class="operator">,</span> penWidth);

              <span class="keyword">if</span> (option<span class="operator">-</span><span class="operator">&gt;</span>state <span class="operator">&amp;</span> (State_Sunken <span class="operator">|</span> State_On))
                  <a href="../qtcore/qtalgorithms-obsolete.html#qSwap-1">qSwap</a>(topPen<span class="operator">,</span> bottomPen);

</pre>
<p>Next, we draw the outline. The top-left half of the outline and the bottom-right half of the outline are drawn using different <a href="../qtgui/qpen.html">QPen</a>s to produce a 3D effect. Normally, the top-left half of the outline is drawn lighter whereas the bottom-right half is drawn darker, but if the button is <a href="qabstractbutton.html#down-prop">down</a> or <a href="qabstractbutton.html#checked-prop">checked</a>, we invert the two <a href="../qtgui/qpen.html">QPen</a>s to give a sunken look to the button.</p>
<pre class="cpp">

              <span class="type">int</span> x1 <span class="operator">=</span> x;
              <span class="type">int</span> x2 <span class="operator">=</span> x <span class="operator">+</span> radius;
              <span class="type">int</span> x3 <span class="operator">=</span> x <span class="operator">+</span> width <span class="operator">-</span> radius;
              <span class="type">int</span> x4 <span class="operator">=</span> x <span class="operator">+</span> width;

              <span class="keyword">if</span> (option<span class="operator">-</span><span class="operator">&gt;</span>direction <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>RightToLeft) {
                  <a href="../qtcore/qtalgorithms-obsolete.html#qSwap-1">qSwap</a>(x1<span class="operator">,</span> x4);
                  <a href="../qtcore/qtalgorithms-obsolete.html#qSwap-1">qSwap</a>(x2<span class="operator">,</span> x3);
              }

              <span class="type"><a href="../qtgui/qpolygon.html">QPolygon</a></span> topHalf;
              topHalf <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x1<span class="operator">,</span> y)
                      <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x4<span class="operator">,</span> y)
                      <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x3<span class="operator">,</span> y <span class="operator">+</span> radius)
                      <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x2<span class="operator">,</span> y <span class="operator">+</span> height <span class="operator">-</span> radius)
                      <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x1<span class="operator">,</span> y <span class="operator">+</span> height);

              painter<span class="operator">-</span><span class="operator">&gt;</span>setClipPath(roundRect);
              painter<span class="operator">-</span><span class="operator">&gt;</span>setClipRegion(topHalf<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>IntersectClip);
              painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(topPen);
              painter<span class="operator">-</span><span class="operator">&gt;</span>drawPath(roundRect);

</pre>
<p>We draw the top-left part of the outline by calling <a href="../qtgui/qpainter.html#drawPath">QPainter::drawPath</a>() with an appropriate <a href="../qtgui/qpainter.html#setClipRegion">clip region</a>. If the <a href="qstyleoption.html#direction-var">layout direction</a> is right-to-left instead of left-to-right, we swap the <code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>x4</code> variables to obtain correct results. On right-to-left desktop, the &quot;light&quot; comes from the top-right corner of the screen instead of the top-left corner; raised and sunken widgets must be drawn accordingly.</p>
<p>The diagram below illustrates how 3D effects are drawn according to the layout direction. The area in red on the diagram corresponds to the <code>topHalf</code> polygon:</p>
<p class="centerAlign"><img src="images/styles-3d.png" alt="" /></p><p>An easy way to test how a style looks in right-to-left mode is to pass the <code>-reverse</code> command-line option to the application. This option is recognized by the <a href="qapplication.html">QApplication</a> constructor.</p>
<pre class="cpp">

              <span class="type"><a href="../qtgui/qpolygon.html">QPolygon</a></span> bottomHalf <span class="operator">=</span> topHalf;
              bottomHalf<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span>(x4<span class="operator">,</span> y <span class="operator">+</span> height);

              painter<span class="operator">-</span><span class="operator">&gt;</span>setClipPath(roundRect);
              painter<span class="operator">-</span><span class="operator">&gt;</span>setClipRegion(bottomHalf<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>IntersectClip);
              painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(bottomPen);
              painter<span class="operator">-</span><span class="operator">&gt;</span>drawPath(roundRect);

              painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(option<span class="operator">-</span><span class="operator">&gt;</span>palette<span class="operator">.</span>foreground()<span class="operator">.</span>color());
              painter<span class="operator">-</span><span class="operator">&gt;</span>setClipping(<span class="keyword">false</span>);
              painter<span class="operator">-</span><span class="operator">&gt;</span>drawPath(roundRect);

              painter<span class="operator">-</span><span class="operator">&gt;</span>restore();
          }
          <span class="keyword">break</span>;
      <span class="keyword">default</span>:
          <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>drawPrimitive(element<span class="operator">,</span> option<span class="operator">,</span> painter<span class="operator">,</span> widget);
      }
  }

</pre>
<p>The bottom-right part of the outline is drawn in a similar fashion. Then we draw a one-pixel wide outline around the entire button, using the <a href="../qtgui/qpalette.html#ColorRole-enum">Foreground</a> component of the <a href="../qtgui/qpalette.html">QPalette</a>.</p>
<p>This completes the <a href="qstyle.html#PrimitiveElement-enum">QStyle::PE_PanelButtonCommand</a> case of the <code>switch</code> statement. Other primitive elements are handled by the base style. Let's now turn to the other <code>NorwegianWoodStyle</code> member functions:</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>drawControl(ControlElement element<span class="operator">,</span>
                                       <span class="keyword">const</span> <span class="type"><a href="qstyleoption.html">QStyleOption</a></span> <span class="operator">*</span>option<span class="operator">,</span>
                                       <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span>
                                       <span class="keyword">const</span> <span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>widget) <span class="keyword">const</span>
  {
      <span class="keyword">switch</span> (element) {
      <span class="keyword">case</span> CE_PushButtonLabel:
          {
              <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span> myButtonOption;
              <span class="keyword">const</span> <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span> <span class="operator">*</span>buttonOption <span class="operator">=</span>
                      qstyleoption_cast<span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="qstyleoptionbutton.html">QStyleOptionButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(option);
              <span class="keyword">if</span> (buttonOption) {
                  myButtonOption <span class="operator">=</span> <span class="operator">*</span>buttonOption;
                  <span class="keyword">if</span> (myButtonOption<span class="operator">.</span>palette<span class="operator">.</span>currentColorGroup()
                          <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>Disabled) {
                      <span class="keyword">if</span> (myButtonOption<span class="operator">.</span>state <span class="operator">&amp;</span> (State_Sunken <span class="operator">|</span> State_On)) {
                          myButtonOption<span class="operator">.</span>palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ButtonText<span class="operator">,</span>
                                  myButtonOption<span class="operator">.</span>palette<span class="operator">.</span>brightText());
                      }
                  }
              }
              <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>drawControl(element<span class="operator">,</span> <span class="operator">&amp;</span>myButtonOption<span class="operator">,</span> painter<span class="operator">,</span> widget);
          }
          <span class="keyword">break</span>;
      <span class="keyword">default</span>:
          <span class="type"><a href="qproxystyle.html">QProxyStyle</a></span><span class="operator">::</span>drawControl(element<span class="operator">,</span> option<span class="operator">,</span> painter<span class="operator">,</span> widget);
      }
  }

</pre>
<p>We reimplement <a href="qstyle.html#drawControl">QStyle::drawControl</a>() to draw the text on a <a href="qpushbutton.html">QPushButton</a> in a bright color when the button is <a href="qabstractbutton.html#down-prop">down</a> or <a href="qabstractbutton.html#checked-prop">checked</a>.</p>
<p>If the <code>option</code> parameter points to a <a href="qstyleoptionbutton.html">QStyleOptionButton</a> object (it normally should), we take a copy of the object and modify its <a href="qstyleoption.html#palette-var">palette</a> member to make the <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::ButtonText</a> be the same as the <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::BrightText</a> component (unless the widget is disabled).</p>
<pre class="cpp">

  <span class="type">void</span> NorwegianWoodStyle<span class="operator">::</span>setTexture(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span> <span class="operator">&amp;</span>palette<span class="operator">,</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ColorRole role<span class="operator">,</span>
                                      <span class="keyword">const</span> <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> <span class="operator">&amp;</span>pixmap)
  {
      <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>NColorGroups; <span class="operator">+</span><span class="operator">+</span>i) {
          <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> color <span class="operator">=</span> palette<span class="operator">.</span>brush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ColorGroup(i)<span class="operator">,</span> role)<span class="operator">.</span>color();
          palette<span class="operator">.</span>setBrush(<span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span><span class="operator">::</span>ColorGroup(i)<span class="operator">,</span> role<span class="operator">,</span> <span class="type"><a href="../qtgui/qbrush.html">QBrush</a></span>(color<span class="operator">,</span> pixmap));
      }
  }

</pre>
<p>The <code>setTexture()</code> function is a private function that sets the <a href="../qtgui/qbrush.html#texture">texture</a> component of the <a href="../qtgui/qbrush.html">QBrush</a>es for a certain <a href="../qtgui/qpalette.html#ColorRole-enum">color role</a>, for all three <a href="../qtgui/qpalette.html#ColorGroup-enum">color groups</a> (active, disabled, inactive). We used it to initialize the Norwegian Wood palette in <code>polish(QPalette &amp;)</code>.</p>
<pre class="cpp">

  <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> NorwegianWoodStyle<span class="operator">::</span>roundRectPath(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> <span class="operator">&amp;</span>rect)
  {
      <span class="type">int</span> radius <span class="operator">=</span> <a href="../qtcore/qtglobal.html#qMin">qMin</a>(rect<span class="operator">.</span>width()<span class="operator">,</span> rect<span class="operator">.</span>height()) <span class="operator">/</span> <span class="number">2</span>;
      <span class="type">int</span> diam <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> radius;

      <span class="type">int</span> x1<span class="operator">,</span> y1<span class="operator">,</span> x2<span class="operator">,</span> y2;
      rect<span class="operator">.</span>getCoords(<span class="operator">&amp;</span>x1<span class="operator">,</span> <span class="operator">&amp;</span>y1<span class="operator">,</span> <span class="operator">&amp;</span>x2<span class="operator">,</span> <span class="operator">&amp;</span>y2);

      <span class="type"><a href="../qtgui/qpainterpath.html">QPainterPath</a></span> path;
      path<span class="operator">.</span>moveTo(x2<span class="operator">,</span> y1 <span class="operator">+</span> radius);
      path<span class="operator">.</span>arcTo(<span class="type"><a href="../qtcore/qrect.html">QRect</a></span>(x2 <span class="operator">-</span> diam<span class="operator">,</span> y1<span class="operator">,</span> diam<span class="operator">,</span> diam)<span class="operator">,</span> <span class="number">0.0</span><span class="operator">,</span> <span class="operator">+</span><span class="number">90.0</span>);
      path<span class="operator">.</span>lineTo(x1 <span class="operator">+</span> radius<span class="operator">,</span> y1);
      path<span class="operator">.</span>arcTo(<span class="type"><a href="../qtcore/qrect.html">QRect</a></span>(x1<span class="operator">,</span> y1<span class="operator">,</span> diam<span class="operator">,</span> diam)<span class="operator">,</span> <span class="number">90.0</span><span class="operator">,</span> <span class="operator">+</span><span class="number">90.0</span>);
      path<span class="operator">.</span>lineTo(x1<span class="operator">,</span> y2 <span class="operator">-</span> radius);
      path<span class="operator">.</span>arcTo(<span class="type"><a href="../qtcore/qrect.html">QRect</a></span>(x1<span class="operator">,</span> y2 <span class="operator">-</span> diam<span class="operator">,</span> diam<span class="operator">,</span> diam)<span class="operator">,</span> <span class="number">180.0</span><span class="operator">,</span> <span class="operator">+</span><span class="number">90.0</span>);
      path<span class="operator">.</span>lineTo(x1 <span class="operator">+</span> radius<span class="operator">,</span> y2);
      path<span class="operator">.</span>arcTo(<span class="type"><a href="../qtcore/qrect.html">QRect</a></span>(x2 <span class="operator">-</span> diam<span class="operator">,</span> y2 <span class="operator">-</span> diam<span class="operator">,</span> diam<span class="operator">,</span> diam)<span class="operator">,</span> <span class="number">270.0</span><span class="operator">,</span> <span class="operator">+</span><span class="number">90.0</span>);
      path<span class="operator">.</span>closeSubpath();
      <span class="keyword">return</span> path;
  }

</pre>
<p>The <code>roundRectPath()</code> function is a private function that constructs a <a href="../qtgui/qpainterpath.html">QPainterPath</a> object for round buttons. The path consists of eight segments: four arc segments for the corners and four lines for the sides.</p>
<p>With around 250 lines of code, we have a fully functional custom style based on one of the predefined styles. Custom styles can be used to provide a distinct look to an application or family of applications.</p>
<a name="widgetgallery-class"></a>
<h2 id="widgetgallery-class">WidgetGallery Class</h2>
<p>For completeness, we will quickly review the <code>WidgetGallery</code> class, which contains the most common Qt widgets and allows the user to change style dynamically. Here's the class definition:</p>
<pre class="cpp">

  <span class="keyword">class</span> WidgetGallery : <span class="keyword">public</span> <span class="type"><a href="qdialog.html">QDialog</a></span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      WidgetGallery(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);

  <span class="keyword">private</span> <span class="keyword">slots</span>:
      <span class="type">void</span> changeStyle(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span> <span class="operator">&amp;</span>styleName);
      <span class="type">void</span> changePalette();
      <span class="type">void</span> advanceProgressBar();

  <span class="keyword">private</span>:
      <span class="type">void</span> createTopLeftGroupBox();
      <span class="type">void</span> createTopRightGroupBox();
      <span class="type">void</span> createBottomLeftTabWidget();
      <span class="type">void</span> createBottomRightGroupBox();
      <span class="type">void</span> createProgressBar();

      <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span> originalPalette;

      <span class="type"><a href="qlabel.html">QLabel</a></span> <span class="operator">*</span>styleLabel;
      <span class="type"><a href="qcombobox.html">QComboBox</a></span> <span class="operator">*</span>styleComboBox;
      <span class="type"><a href="qcheckbox.html">QCheckBox</a></span> <span class="operator">*</span>useStylePaletteCheckBox;
      <span class="type"><a href="qcheckbox.html">QCheckBox</a></span> <span class="operator">*</span>disableWidgetsCheckBox;
      ...
  };

</pre>
<p>Here's the <code>WidgetGallery</code> constructor:</p>
<pre class="cpp">

  WidgetGallery<span class="operator">::</span>WidgetGallery(<span class="type"><a href="qwidget.html">QWidget</a></span> <span class="operator">*</span>parent)
      : <span class="type"><a href="qdialog.html">QDialog</a></span>(parent)
  {
      originalPalette <span class="operator">=</span> <span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>palette();

      styleComboBox <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qcombobox.html">QComboBox</a></span>;
      styleComboBox<span class="operator">-</span><span class="operator">&gt;</span>addItem(<span class="string">&quot;NorwegianWood&quot;</span>);
      styleComboBox<span class="operator">-</span><span class="operator">&gt;</span>addItems(<span class="type"><a href="qstylefactory.html">QStyleFactory</a></span><span class="operator">::</span>keys());

      styleLabel <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qlabel.html">QLabel</a></span>(tr(<span class="string">&quot;&amp;Style:&quot;</span>));
      styleLabel<span class="operator">-</span><span class="operator">&gt;</span>setBuddy(styleComboBox);

      useStylePaletteCheckBox <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qcheckbox.html">QCheckBox</a></span>(tr(<span class="string">&quot;&amp;Use style's standard palette&quot;</span>));
      useStylePaletteCheckBox<span class="operator">-</span><span class="operator">&gt;</span>setChecked(<span class="keyword">true</span>);

      disableWidgetsCheckBox <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qcheckbox.html">QCheckBox</a></span>(tr(<span class="string">&quot;&amp;Disable widgets&quot;</span>));

      createTopLeftGroupBox();
      createTopRightGroupBox();
      createBottomLeftTabWidget();
      createBottomRightGroupBox();
      createProgressBar();

</pre>
<p>We start by creating child widgets. The <b>Style</b> combobox is initialized with all the styles known to <a href="qstylefactory.html">QStyleFactory</a>, in addition to <code>NorwegianWood</code>. The <code>create..&#x2e;()</code> functions are private functions that set up the various parts of the <code>WidgetGallery</code>.</p>
<pre class="cpp">

      connect(styleComboBox<span class="operator">,</span> SIGNAL(activated(<span class="type"><a href="../qtcore/qstring.html">QString</a></span>))<span class="operator">,</span>
              <span class="keyword">this</span><span class="operator">,</span> SLOT(changeStyle(<span class="type"><a href="../qtcore/qstring.html">QString</a></span>)));
      connect(useStylePaletteCheckBox<span class="operator">,</span> SIGNAL(toggled(bool))<span class="operator">,</span>
              <span class="keyword">this</span><span class="operator">,</span> SLOT(changePalette()));
      connect(disableWidgetsCheckBox<span class="operator">,</span> SIGNAL(toggled(bool))<span class="operator">,</span>
              topLeftGroupBox<span class="operator">,</span> SLOT(setDisabled(bool)));
      connect(disableWidgetsCheckBox<span class="operator">,</span> SIGNAL(toggled(bool))<span class="operator">,</span>
              topRightGroupBox<span class="operator">,</span> SLOT(setDisabled(bool)));
      connect(disableWidgetsCheckBox<span class="operator">,</span> SIGNAL(toggled(bool))<span class="operator">,</span>
              bottomLeftTabWidget<span class="operator">,</span> SLOT(setDisabled(bool)));
      connect(disableWidgetsCheckBox<span class="operator">,</span> SIGNAL(toggled(bool))<span class="operator">,</span>
              bottomRightGroupBox<span class="operator">,</span> SLOT(setDisabled(bool)));

</pre>
<p>We connect the <b>Style</b> combobox to the <code>changeStyle()</code> private slot, the <b>Use style's standard palette</b> check box to the <code>changePalette()</code> slot, and the <b>Disable widgets</b> check box to the child widgets' <a href="qwidget.html#setDisabled">setDisabled()</a> slot.</p>
<pre class="cpp">

      <span class="type"><a href="qhboxlayout.html">QHBoxLayout</a></span> <span class="operator">*</span>topLayout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qhboxlayout.html">QHBoxLayout</a></span>;
      topLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(styleLabel);
      topLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(styleComboBox);
      topLayout<span class="operator">-</span><span class="operator">&gt;</span>addStretch(<span class="number">1</span>);
      topLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(useStylePaletteCheckBox);
      topLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(disableWidgetsCheckBox);

      <span class="type"><a href="qgridlayout.html">QGridLayout</a></span> <span class="operator">*</span>mainLayout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qgridlayout.html">QGridLayout</a></span>;
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addLayout(topLayout<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(topLeftGroupBox<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(topRightGroupBox<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(bottomLeftTabWidget<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">0</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(bottomRightGroupBox<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">1</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(progressBar<span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>setRowStretch(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>setRowStretch(<span class="number">2</span><span class="operator">,</span> <span class="number">1</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>setColumnStretch(<span class="number">0</span><span class="operator">,</span> <span class="number">1</span>);
      mainLayout<span class="operator">-</span><span class="operator">&gt;</span>setColumnStretch(<span class="number">1</span><span class="operator">,</span> <span class="number">1</span>);
      setLayout(mainLayout);

      setWindowTitle(tr(<span class="string">&quot;Styles&quot;</span>));
      changeStyle(<span class="string">&quot;NorwegianWood&quot;</span>);
  }

</pre>
<p>Finally, we put the child widgets in layouts.</p>
<pre class="cpp">

  <span class="type">void</span> WidgetGallery<span class="operator">::</span>changeStyle(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span> <span class="operator">&amp;</span>styleName)
  {
      <span class="keyword">if</span> (styleName <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;NorwegianWood&quot;</span>) {
          <span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>setStyle(<span class="keyword">new</span> NorwegianWoodStyle);
      } <span class="keyword">else</span> {
          <span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>setStyle(<span class="type"><a href="qstylefactory.html">QStyleFactory</a></span><span class="operator">::</span>create(styleName));
      }
      changePalette();
  }

</pre>
<p>When the user changes the style in the combobox, we call <a href="qapplication.html#setStyle">QApplication::setStyle</a>() to dynamically change the style of the application.</p>
<pre class="cpp">

  <span class="type">void</span> WidgetGallery<span class="operator">::</span>changePalette()
  {
      <span class="keyword">if</span> (useStylePaletteCheckBox<span class="operator">-</span><span class="operator">&gt;</span>isChecked())
          <span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>setPalette(<span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>style()<span class="operator">-</span><span class="operator">&gt;</span>standardPalette());
      <span class="keyword">else</span>
          <span class="type"><a href="qapplication.html">QApplication</a></span><span class="operator">::</span>setPalette(originalPalette);
  }

</pre>
<p>If the user turns the <b>Use style's standard palette</b> on, the current style's <a href="qstyle.html#standardPalette">standard palette</a> is used; otherwise, the system's default palette is honored.</p>
<p>For the Norwegian Wood style, this makes no difference because we always override the palette with our own palette in <code>NorwegianWoodStyle::polish()</code>.</p>
<pre class="cpp">

  <span class="type">void</span> WidgetGallery<span class="operator">::</span>advanceProgressBar()
  {
      <span class="type">int</span> curVal <span class="operator">=</span> progressBar<span class="operator">-</span><span class="operator">&gt;</span>value();
      <span class="type">int</span> maxVal <span class="operator">=</span> progressBar<span class="operator">-</span><span class="operator">&gt;</span>maximum();
      progressBar<span class="operator">-</span><span class="operator">&gt;</span>setValue(curVal <span class="operator">+</span> (maxVal <span class="operator">-</span> curVal) <span class="operator">/</span> <span class="number">100</span>);
  }

</pre>
<p>The <code>advanceProgressBar()</code> slot is called at regular intervals to advance the progress bar. Since we don't know how long the user will keep the Styles application running, we use a logarithmic formula: The closer the progress bar gets to 100%, the slower it advances.</p>
<p>We will review <code>createProgressBar()</code> in a moment.</p>
<pre class="cpp">

  <span class="type">void</span> WidgetGallery<span class="operator">::</span>createTopLeftGroupBox()
  {
      topLeftGroupBox <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qgroupbox.html">QGroupBox</a></span>(tr(<span class="string">&quot;Group 1&quot;</span>));

      radioButton1 <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qradiobutton.html">QRadioButton</a></span>(tr(<span class="string">&quot;Radio button 1&quot;</span>));
      radioButton2 <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qradiobutton.html">QRadioButton</a></span>(tr(<span class="string">&quot;Radio button 2&quot;</span>));
      radioButton3 <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qradiobutton.html">QRadioButton</a></span>(tr(<span class="string">&quot;Radio button 3&quot;</span>));
      radioButton1<span class="operator">-</span><span class="operator">&gt;</span>setChecked(<span class="keyword">true</span>);

      checkBox <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qcheckbox.html">QCheckBox</a></span>(tr(<span class="string">&quot;Tri-state check box&quot;</span>));
      checkBox<span class="operator">-</span><span class="operator">&gt;</span>setTristate(<span class="keyword">true</span>);
      checkBox<span class="operator">-</span><span class="operator">&gt;</span>setCheckState(<span class="type"><a href="../qtcore/qt.html">Qt</a></span><span class="operator">::</span>PartiallyChecked);

      <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span> <span class="operator">*</span>layout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span>;
      layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(radioButton1);
      layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(radioButton2);
      layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(radioButton3);
      layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(checkBox);
      layout<span class="operator">-</span><span class="operator">&gt;</span>addStretch(<span class="number">1</span>);
      topLeftGroupBox<span class="operator">-</span><span class="operator">&gt;</span>setLayout(layout);
  }

</pre>
<p>The <code>createTopLeftGroupBox()</code> function creates the <a href="qgroupbox.html">QGroupBox</a> that occupies the top-left corner of the <code>WidgetGallery</code>. We skip the <code>createTopRightGroupBox()</code>, <code>createBottomLeftTabWidget()</code>, and <code>createBottomRightGroupBox()</code> functions, which are very similar.</p>
<pre class="cpp">

  <span class="type">void</span> WidgetGallery<span class="operator">::</span>createProgressBar()
  {
      progressBar <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qprogressbar.html">QProgressBar</a></span>;
      progressBar<span class="operator">-</span><span class="operator">&gt;</span>setRange(<span class="number">0</span><span class="operator">,</span> <span class="number">10000</span>);
      progressBar<span class="operator">-</span><span class="operator">&gt;</span>setValue(<span class="number">0</span>);

      <span class="type"><a href="../qtcore/qtimer.html">QTimer</a></span> <span class="operator">*</span>timer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qtimer.html">QTimer</a></span>(<span class="keyword">this</span>);
      connect(timer<span class="operator">,</span> SIGNAL(timeout())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(advanceProgressBar()));
      timer<span class="operator">-</span><span class="operator">&gt;</span>start(<span class="number">1000</span>);
  }

</pre>
<p>In <code>createProgressBar()</code>, we create a <a href="qprogressbar.html">QProgressBar</a> at the bottom of the <code>WidgetGallery</code> and connect its <a href="../qtcore/qtimer.html#timeout">timeout()</a> signal to the <code>advanceProgressBar()</code> slot.</p>
<p>Files:</p>
<ul>
<li><a href="qtwidgets-widgets-styles-norwegianwoodstyle-cpp.html">widgets/styles/norwegianwoodstyle.cpp</a></li>
<li><a href="qtwidgets-widgets-styles-norwegianwoodstyle-h.html">widgets/styles/norwegianwoodstyle.h</a></li>
<li><a href="qtwidgets-widgets-styles-widgetgallery-cpp.html">widgets/styles/widgetgallery.cpp</a></li>
<li><a href="qtwidgets-widgets-styles-widgetgallery-h.html">widgets/styles/widgetgallery.h</a></li>
<li><a href="qtwidgets-widgets-styles-main-cpp.html">widgets/styles/main.cpp</a></li>
<li><a href="qtwidgets-widgets-styles-styles-pro.html">widgets/styles/styles.pro</a></li>
<li><a href="qtwidgets-widgets-styles-styles-qrc.html">widgets/styles/styles.qrc</a></li>
</ul>
<p>Images:</p>
<ul>
<li><a href="images/used-in-examples/widgets/styles/images/woodbackground.png">widgets/styles/images/woodbackground.png</a></li>
<li><a href="images/used-in-examples/widgets/styles/images/woodbutton.png">widgets/styles/images/woodbutton.png</a></li>
</ul>
</div>
<!-- @@@widgets/styles -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
